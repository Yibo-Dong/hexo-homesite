<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Good Good Study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Good Good Study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Asp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Good Good Study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Good Good Study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Day Day up</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/Effective-Modern-C++-(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Effective-Modern-C++-(1)/" class="post-title-link" itemprop="url">Effective Modern C++ (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 19:00:00 / Modified: 19:54:17" itemprop="dateCreated datePublished" datetime="2022-05-05T19:00:00+08:00">2022-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-Modern-C/" itemprop="url" rel="index"><span itemprop="name">Effective Modern C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Effective-Modern-C-2-Auto"><a href="#Effective-Modern-C-2-Auto" class="headerlink" title="Effective Modern C++ (2) Auto"></a>Effective Modern C++ (2) Auto</h2><h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This chapter talks about ‘auto’. This keyword is supported from C++11, and is very convenient at most times. However, in some occasions, its behavior may seem just ‘wrong’ to programmers. This chapter has two items, introducing us to auto’s ins and outs.</p>
<h3 id="Item-5-Prefer-auto-to-explicit-type-declarations"><a href="#Item-5-Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Item 5 Prefer auto to explicit type declarations."></a>Item 5 Prefer auto to explicit type declarations.</h3><h5 id="Why-auto-is-good"><a href="#Why-auto-is-good" class="headerlink" title="Why auto is good:"></a>Why <code>auto</code> is good:</h5><ul>
<li>write less</li>
<li>when it comes to holding a closure, it uses as much memory as the closure requires. <ul>
<li><code>std::function</code>, on the contrary, has a fixed size for any given signature, and thus may yield out-of-memory exceptions.</li>
</ul>
</li>
<li>can help reduce uninitialized problems</li>
<li>can be cross-platform.<ul>
<li>e.g. <code>std::vector&lt;int&gt;::size_type</code> becomes 64 bits on 64-bit Windows, while<code>unsigned</code> is still 32 bits.</li>
</ul>
</li>
<li>avoid const-missing in for-range and so on.<ul>
<li>e.g. key part of unordered_map in const. If you write something without a const qualification, it will be copied every time.</li>
</ul>
</li>
<li>enhance readability.</li>
</ul>
<h5 id="Why-auto-is-not-perfect"><a href="#Why-auto-is-not-perfect" class="headerlink" title="Why auto is not perfect:"></a>Why <code>auto</code> is not perfect:</h5><ul>
<li>the deduced type may be “strange” <ul>
<li>e.g. <code>std::initial_list</code></li>
</ul>
</li>
<li>Seen in Item 6</li>
</ul>
<h5 id="other-notes"><a href="#other-notes" class="headerlink" title="other notes:"></a>other notes:</h5><ul>
<li><code>std::function</code> objects can refer to any callable object, i.e. , to anything that can be invoked like a function.</li>
</ul>
<h3 id="Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Item 6 Use the explicitly typed initializer idiom when auto deduces undesired types."></a>Item 6 Use the explicitly typed initializer idiom when <code>auto</code> deduces undesired types.</h3><h5 id="When-auto-zig-zag"><a href="#When-auto-zig-zag" class="headerlink" title="When auto zig-zag:"></a>When <code>auto</code> zig-zag:</h5><ul>
<li><p>lack of the implicit cast</p>
<ul>
<li><code>std::vector&lt;bool&gt;[1]</code>, without <code>bool</code> specified, turns out to be dangling pointers(pointing to temporary objects) on some implementations.</li>
</ul>
</li>
<li><p>invisible proxy class</p>
<ul>
<li><p>just like <code>std::vector::reference</code>,</p>
</li>
<li><p>Expression templates</p>
<ul>
<li>as to numerical operations, if operators returns a proxy for the result instead of the result itself, it would be faster.</li>
</ul>
</li>
<li><p>they are not designed to live longer than a single statement.</p>
</li>
<li><p>should avoid:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> somevar = expression of invisible proxy <span class="keyword">class</span> types.</span><br></pre></td></tr></table></figure>
</li>
<li><p>how to avoid: </p>
<ul>
<li>static_cast&lt;&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Other notes:</p>
<ul>
<li><code>std::vector&lt;bool&gt;</code> is specified to represent its bools in packed form, one bit per bool.</li>
<li>C++ forbids reference to bits.</li>
<li>how to find invisible proxy class:<ul>
<li>function signatures will reflect them: operator returning a reference.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/Effective-Modern-C++-(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Effective-Modern-C++-(2)/" class="post-title-link" itemprop="url">Effective Modern C++ (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 19:00:00 / Modified: 19:54:42" itemprop="dateCreated datePublished" datetime="2022-05-05T19:00:00+08:00">2022-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-Modern-C/" itemprop="url" rel="index"><span itemprop="name">Effective Modern C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Effective-Modern-C-2-Auto"><a href="#Effective-Modern-C-2-Auto" class="headerlink" title="Effective Modern C++ (2) Auto"></a>Effective Modern C++ (2) Auto</h2><h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This chapter talks about ‘auto’. This keyword is supported from C++11, and is very convenient at most times. However, in some occasions, its behavior may seem just ‘wrong’ to programmers. This chapter has two items, introducing us to auto’s ins and outs.</p>
<h3 id="Item-5-Prefer-auto-to-explicit-type-declarations"><a href="#Item-5-Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Item 5 Prefer auto to explicit type declarations."></a>Item 5 Prefer auto to explicit type declarations.</h3><h5 id="Why-auto-is-good"><a href="#Why-auto-is-good" class="headerlink" title="Why auto is good:"></a>Why <code>auto</code> is good:</h5><ul>
<li>write less</li>
<li>when it comes to holding a closure, it uses as much memory as the closure requires. <ul>
<li><code>std::function</code>, on the contrary, has a fixed size for any given signature, and thus may yield out-of-memory exceptions.</li>
</ul>
</li>
<li>can help reduce uninitialized problems</li>
<li>can be cross-platform.<ul>
<li>e.g. <code>std::vector&lt;int&gt;::size_type</code> becomes 64 bits on 64-bit Windows, while<code>unsigned</code> is still 32 bits.</li>
</ul>
</li>
<li>avoid const-missing in for-range and so on.<ul>
<li>e.g. key part of unordered_map in const. If you write something without a const qualification, it will be copied every time.</li>
</ul>
</li>
<li>enhance readability.</li>
</ul>
<h5 id="Why-auto-is-not-perfect"><a href="#Why-auto-is-not-perfect" class="headerlink" title="Why auto is not perfect:"></a>Why <code>auto</code> is not perfect:</h5><ul>
<li>the deduced type may be “strange” <ul>
<li>e.g. <code>std::initial_list</code></li>
</ul>
</li>
<li>Seen in Item 6</li>
</ul>
<h5 id="other-notes"><a href="#other-notes" class="headerlink" title="other notes:"></a>other notes:</h5><ul>
<li><code>std::function</code> objects can refer to any callable object, i.e. , to anything that can be invoked like a function.</li>
</ul>
<h3 id="Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Item 6 Use the explicitly typed initializer idiom when auto deduces undesired types."></a>Item 6 Use the explicitly typed initializer idiom when <code>auto</code> deduces undesired types.</h3><h5 id="When-auto-zig-zag"><a href="#When-auto-zig-zag" class="headerlink" title="When auto zig-zag:"></a>When <code>auto</code> zig-zag:</h5><ul>
<li><p>lack of the implicit cast</p>
<ul>
<li><code>std::vector&lt;bool&gt;[1]</code>, without <code>bool</code> specified, turns out to be dangling pointers(pointing to temporary objects) on some implementations.</li>
</ul>
</li>
<li><p>invisible proxy class</p>
<ul>
<li><p>just like <code>std::vector::reference</code>,</p>
</li>
<li><p>Expression templates</p>
<ul>
<li>as to numerical operations, if operators returns a proxy for the result instead of the result itself, it would be faster.</li>
</ul>
</li>
<li><p>they are not designed to live longer than a single statement.</p>
</li>
<li><p>should avoid:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> somevar = expression of invisible proxy <span class="keyword">class</span> types.</span><br></pre></td></tr></table></figure>
</li>
<li><p>how to avoid: </p>
<ul>
<li>static_cast&lt;&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Other notes:</p>
<ul>
<li><code>std::vector&lt;bool&gt;</code> is specified to represent its bools in packed form, one bit per bool.</li>
<li>C++ forbids reference to bits.</li>
<li>how to find invisible proxy class:<ul>
<li>function signatures will reflect them: operator returning a reference.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E5%85%B3%E4%BA%8E%E6%A0%87%E7%AD%BE%E5%88%86%E5%8F%91%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E5%85%B3%E4%BA%8E%E6%A0%87%E7%AD%BE%E5%88%86%E5%8F%91%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">关于标签分发的一点记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-26 12:47:00 / Modified: 13:12:46" itemprop="dateCreated datePublished" datetime="2022-04-26T12:47:00+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/working-notes/" itemprop="url" rel="index"><span itemprop="name">working notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工作的时候，听同事提到了“使用类模板偏特化来进行标签分发”的设计思路。虽然在前面设计chiron的插桩方法时，已经实际使用过“标签分发”的想法，但当时只是灵机一动，此时才知道有这样一种概念。因而做一些记录。</p>
<p>本文参考了这篇<a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2018/04/27/tag-dispatching/">blog</a></p>
<h4 id="什么是标签分发（tag-dispatching）"><a href="#什么是标签分发（tag-dispatching）" class="headerlink" title="什么是标签分发（tag dispatching）"></a>什么是标签分发（tag dispatching）</h4><p>在C++中，多态允许同一函数名具有不同的参数类型列表从而形成多态。但相同的参数类型列表是不被允许的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">2</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">3</span>; &#125; <span class="comment">// no. redefinition</span></span><br></pre></td></tr></table></figure>

<p>如何解决同样的参数，不同的行为呢？</p>
<p>可以使用标签分发机制，也即定义不同的类型，用以描述该函数所进行的行为类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tag1</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tag2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, tag1 x )</span> </span>&#123; cout &lt;&lt; <span class="number">2</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, tag2 x )</span> </span>&#123; cout &lt;&lt; <span class="number">3</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br></pre></td></tr></table></figure>

<p>不过需要注意的是：如果是无参数的，那么标签就形成了唯一的参数。如果用在构造函数中，需要注意避免歧义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">constructThisWay</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">constructThatWay</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(constructThisWay)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(constructThatWay)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">((MyClass::constructThisWay()))</span></span>; <span class="comment">// MyClass x</span></span><br><span class="line"><span class="function">MyClass <span class="title">y</span><span class="params">(MyClass::constructThisWay())</span></span>;   <span class="comment">// MyClass y(MyClass::constructThisWay (*)()). viewed as a function declaration, taking a function-pointer as parm.</span></span><br><span class="line"><span class="function">MyClass <span class="title">z</span><span class="params">(MyClass::constructThisWay&#123;&#125;)</span></span>; <span class="comment">// uniform initialization.</span></span><br></pre></td></tr></table></figure>

<p>这一点可以通过使用static constructor 或者 uniform initialization 来避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ConstructThisWay</span>&#123;&#125; constructThisWay;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ConstructThatWay</span>&#123;&#125; constructThatWay;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(ConstructThisWay)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(ConstructThatWay)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">(MyClass::constructThatWay)</span></span>; <span class="comment">// no more a type, but a tag object.</span></span><br></pre></td></tr></table></figure>



<h4 id="何时使用标签分发"><a href="#何时使用标签分发" class="headerlink" title="何时使用标签分发"></a>何时使用标签分发</h4><p>原文提出了这样一种观点，我认可他的观点：</p>
<blockquote>
<p>使用标签分发来给“行为”附魔，而不要给“数据”附魔。</p>
</blockquote>
<p>例如，即使是同样类型，但是传入的数据含义并不相同，不应该使用标签分发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleBad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">buildWithRadius</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">buildWithDiameter</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleBad</span><span class="params">(<span class="type">double</span> radius, buildWithRadius)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleBad</span><span class="params">(<span class="type">double</span> diameter, buildWithDiameter)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleGood</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleGood</span><span class="params">(Radius radius)</span></span>; <span class="comment">// different types.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleGood</span><span class="params">(Diameter diameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">用宏实现函数多态的一个技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-26 11:07:00 / Modified: 13:16:04" itemprop="dateCreated datePublished" datetime="2022-04-26T11:07:00+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/working-notes/" itemprop="url" rel="index"><span itemprop="name">working notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前的工作中，遇到了这样的问题：</p>
<p>diagnostic engine 限定了location必须valid，否则assertion会出错。</p>
<p>由于diagnostic engine对于信息的处理函数并非void类型，并不能通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loc.<span class="built_in">invalid</span>()) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>来回避。</p>
<p>所以需要在源头上控制有效性。也即，在<code>diag()</code>之前先检查有效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// in Preprocessing</span><br><span class="line">if(loc.valid())</span><br><span class="line">	diag(loc,msg);</span><br><span class="line">// in AST</span><br><span class="line">if(loc.valid())</span><br><span class="line">    checker-&gt;diag(loc,msg);</span><br></pre></td></tr></table></figure>

<p>但在非发布环境中，是不希望直接掩盖掉invalid信息的。所以设计了一个宏来控制是否做location verification，不过和这里没有关系，不做展开。</p>
<p>这时候，一种自然的想法是：如何把这两个函数统一起来？</p>
<p>实质上，它们唯一的区别在于有没有checker，考虑到每一个checker可能具有不同的类型，这里计划直接使用宏来处理（当然，写一个模板也是没有问题的）。</p>
<p>所以说，两个<code>diag</code>函数形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIAG_TWO_PARM(loc, mes)  <span class="keyword">if</span> (loc.isValid()) diag(loc, mes)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIAG_THREE_PARM(checker, loc, mes) <span class="keyword">if</span> (loc.isValid()) checker-&gt;diag(loc, mes)</span></span><br></pre></td></tr></table></figure>

<p>应该如何统一呢？</p>
<p>这里使用了宏的变参函数来实现：</p>
<p><code>__VA__ARGS</code>即为宏函数中所传入的参数。而我们只需要让<code>n(每个宏函数在函数列表中所处的位置) + n(argc) == const</code> 就可以了。</p>
<p>具体来说，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_4TH_PARM(_1,_2,_3,func,...) func</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_B4_DIAG(...) GET_4TH_PARM(__VA_ARGS__, DIAG_THREE_PARM, DIAG_TWO_PARM, ...)(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH3/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-25 19:00:00" itemprop="dateCreated datePublished" datetime="2022-04-25T19:00:00+08:00">2022-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-26 14:37:53" itemprop="dateModified" datetime="2022-04-26T14:37:53+08:00">2022-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH3-基于AST的checker"><a href="#CH3-基于AST的checker" class="headerlink" title="CH3 基于AST的checker"></a>CH3 基于AST的checker</h3><p>很多简单的checker可以直接通过检查语法树并匹配特征来完成。由于不适用path-sensitive 引擎，这样写的checker很快，而且有不错的TP（True Positive）率，但并不能检查极端情况。</p>
<p>这一章我们会讨论基于AST检查的两种路线：<code>AST visitor</code> 和<code>AST matcher</code>。一般来说这两个有一个就够用了，不过有时候也许你会在同一个checker里同时用这两个。</p>
<p>需要说明的是，基于AST的checker并不是CSA的强项所在，尽管CSA里确实有那么几个基于AST的checker。如果你只需要AST的信息，更合适的工具也许是<code>clang-tidy</code>。</p>
<p>不过换个角度说，在path-sensitive引擎中，带着用到基于AST的checker是很正常的。那么更多地了解path-sensitive所订阅的事件背后的语法也是很有必要的。于是，这一章我们会学习如何写只用AST的checker，不过相关的技术其实也可以迁移到path-sensitive checker中去，所以掌握它们其实很有用。</p>
<h4 id="3-1-非路径敏感checker的回调函数"><a href="#3-1-非路径敏感checker的回调函数" class="headerlink" title="3.1 非路径敏感checker的回调函数"></a>3.1 非路径敏感checker的回调函数</h4><p>正如前面提到过的，如果一个path-sensitive checker都没有，path-sensitive引擎是不会启动的，速度会快很多。同样，因为引擎没有启动，而很多数据结构都不会被建立。因而，能用的回调函数接口并不是很多。能用的里面，比较有用的两个分别是<code>check::EndOfTranslationUnit</code> 和 <code>check::ASTCodeBody</code>。</p>
<h5 id="3-1-1-check-EndOfTranslationUnit"><a href="#3-1-1-check-EndOfTranslationUnit" class="headerlink" title="3.1.1 check::EndOfTranslationUnit"></a>3.1.1 check::EndOfTranslationUnit</h5><p>原型为： <code>void checkEndOfTranslationUnit(const TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;BR) const</code>;</p>
<p>在这个回调函数中，程序的整个AST是可以拿到的。</p>
<p>访问整个AST的入口，也就是整个翻译单元（Translation Unit）的声明，是直接以参数形式传入的。</p>
<p>这个回调函数的使用场景通常是：要检查的不只是可执行代码，还包括各种声明。</p>
<h5 id="3-1-2-check-ASTCodeBody"><a href="#3-1-2-check-ASTCodeBody" class="headerlink" title="3.1.2 check::ASTCodeBody"></a>3.1.2 check::ASTCodeBody</h5><p>原型为：<code>void checkASTCodeBody(const Decl* D, AnalysisManager &amp;AM, BugReporter &amp;BR) const;</code></p>
<p>在这个回调函数中，每次调用将会返回函数的声明。其code body是分析器通常会需要分析的，可以通过<code>D-&gt;getBody()</code>来获得。</p>
<p>这个回调函数的使用场景通常是：要检查的只是可执行代码。</p>
<h5 id="3-1-3-check-ASTDecl-lt-T-gt"><a href="#3-1-3-check-ASTDecl-lt-T-gt" class="headerlink" title="3.1.3 check::ASTDecl&lt;T&gt;"></a>3.1.3 check::ASTDecl&lt;T&gt;</h5><p>原型为：<code>void checASTDecl(const T* D, AnalysisManager &amp;AM, BugReporter &amp;BR) const;</code></p>
<p>这个回调函数被用于检查所有AST上类型为<code>T</code>的声明。例如：寻找所有的<code>VarDecl</code>，或者所有的<code>FieldDecl</code>。这通常是declaration Visitor的一种便捷替代。</p>
<h4 id="3-2-AST-Visitors"><a href="#3-2-AST-Visitors" class="headerlink" title="3.2 AST Visitors"></a>3.2 AST Visitors</h4><p>AST visitor是访问Clang的语法树的最简单的方法。clang提供了数量极多、语法相近的visitor。有两类有用的visitor：</p>
<ul>
<li><code>ConstStmtVisitor</code>，用于检查代码主体。</li>
<li><code>ConstDeclVisitor</code>，检查代码主体之外的声明，例如全局变量。</li>
</ul>
<p>想要实现一个Visitor，你需要继承一个它的类，并实现所需要的针对不同AST节点的回调函数需要注意的是，即使没有实现针对特定类型的节点的回调函数，如果实现了针对其基础类型的回调函数，它也会被访问到。</p>
<p>例如，即使没有实现<code>CXXOperatorCallExpr</code>，它也会因为以下中的任意一个被实现而被访问：</p>
<ul>
<li><code>VisitCallExpr()</code></li>
<li><code>VisitExpr()</code></li>
<li><code>VisitStmt()</code></li>
</ul>
<h5 id="3-2-1-实现一个简单的statement-visitor"><a href="#3-2-1-实现一个简单的statement-visitor" class="headerlink" title="3.2.1 实现一个简单的statement visitor"></a>3.2.1 实现一个简单的statement visitor</h5><p>从一个简单的例子开始，我们看看我们能不能使用AST visitor来重写一下<code>MainCallChecker</code>。</p>
<p>第一步，我们来声明AST visitor。visitor保存有用以抛出报告的<code>BugReporter</code>的引用，以及用于提供位置信息的当前的<code>AnalysisDeclContext</code>。后者包裹起了我们在分析的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WalkAST</span>: <span class="keyword">public</span> ConstStmtVisitor&lt;WalkAST&gt;&#123;</span><br><span class="line">        BugReporter &amp;BR;</span><br><span class="line">        AnalysisDeclContext *ADC;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">VisitChildren</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">WalkAST</span>(BugReporter &amp;Reporter, AnalysisDeclContext *Context): <span class="built_in">BR</span>(Reporter), <span class="built_in">ADC</span>(Context) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">VisitStmt</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">VisitCallExpr</span><span class="params">(<span class="type">const</span> CallExpr *CE)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个visitor定义了两个public的回调函数：<code>VisitCallExpr(...)</code>用于处理函数调用表达式，以及<code>VisitStmt(...)</code>用于处理其它的statement。</p>
<p>这些回调函数有一个共同点：他们在结束访问自身的statement之后，需要访问子statement。这种操作我们切分到<code>VisitChildren(...)</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WalkAST::VisitChildren</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Stmt::const_child_iterator I = S-&gt;<span class="built_in">child_begin</span>(), E=S-&gt;<span class="built_in">child_end</span>(); I!=E; ++I)</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">const</span> Stmt *Child = *I)</span><br><span class="line">            <span class="built_in">Visit</span>(Child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 于是，<code>VisitStmt</code>除了<code>VisitChildren</code>以外不需要做别的了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WalkAST::VisitStmt</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">VisitChildren</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数checker的逻辑被存在<code>VisitCallExpr(...)</code>中。我们获取当前所调用的函数的标识符，看看它是否恰巧是”main”。如果是，那么我们就抛出一个path-sensitive的report。注意，由于没有可用的<code>CheckerContext</code>包裹，所以需要直接访问<code>BugReporter</code>；而且获取位置信息也有点麻烦。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> WalkAST ::<span class="built_in">VisitCallExpr</span>(<span class="type">const</span> CallExpr *CE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> FunctionDecl *FD = CE-&gt;<span class="built_in">getDirectCallee</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = FD-&gt;<span class="built_in">getIdentifier</span>())</span><br><span class="line">            <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">                SourceRange R = CE-&gt;<span class="built_in">getSourceRange</span>();</span><br><span class="line">                PathDiagnosticLocation ELoc = PathDiagnosticLocation ::<span class="built_in">createBegin</span>(</span><br><span class="line">                    CE, BR.<span class="built_in">getSourceManager</span>(), ADC);</span><br><span class="line">                BR.<span class="built_in">EmitBasicReport</span>(ADC-&gt;<span class="built_in">getDecl</span>(), <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;Call to main&quot;</span>, ELoc, R);</span><br><span class="line">            &#125; <span class="comment">// Not working on present version now, need Checkername</span></span><br><span class="line">    <span class="built_in">VisitChildren</span>(CE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是visitor的实现。现在我们就只需要创建一个，然后给它一些代码来访问。既然“所有代码”是一个declaration而不是一个statement，我们选择订阅<code>check::ASTCodeBody</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallCheckerAST</span> : <span class="keyword">public</span> Checker&lt;check::ASTCodeBody&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkASTCodeBody</span><span class="params">(<span class="type">const</span> Decl *D, AnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BugReporter &amp;B)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MainCallCheckerAST ::<span class="built_in">checkASTCodeBody</span>(<span class="type">const</span> Decl *D, AnalysisManager &amp;AM,BugReporter &amp;BR) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="function">WalkAST <span class="title">Walker</span><span class="params">(BR, AM.getAnalysisDeclContext(D))</span></span>;</span><br><span class="line">    Walker.<span class="built_in">Visit</span>(D-&gt;<span class="built_in">getBody</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，这个visitor从包含了函数体的compound statement开始，下降到其中的子statement。</p>
<p>到此为止checker就准备好了。但是对前面的例子它并不会报错，因为我们只检查直接函数调用，而不检查通过函数指针的调用。所以我们写一个新的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">main</span>(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// call to main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-合并statement-和declaration-的visitor"><a href="#3-2-2-合并statement-和declaration-的visitor" class="headerlink" title="3.2.2 合并statement 和declaration 的visitor"></a>3.2.2 合并statement 和declaration 的visitor</h5><p>如果需要在内部和并这两种visitor以同时访问statement和declaration，就同时继承这两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WalkAST</span> : <span class="keyword">public</span> ConstStmtVisitor&lt;WalkAST&gt;,</span><br><span class="line"><span class="keyword">public</span> ConstDeclVisitor&lt;WalkAST&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ConstStmtVisitor&lt;WalkAST&gt;::Visit;</span><br><span class="line">    <span class="keyword">using</span> ConstDeclVisitor&lt;WalkAST&gt;::Visit;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-AST-matcher"><a href="#3-3-AST-matcher" class="headerlink" title="3.3 AST matcher"></a>3.3 AST matcher</h4><p>AST matcher 是在AST上寻找简单代码模式的新接口。它允许对代码的模式特征编写极其简洁的声明式定义，几乎和用自然语言的文字描述它们一样短。并提供了一个对应操作的接口。 AST matcher更适合于简单的代码模式特征，因为其简单性和代码可读性，所以它并不像AST访问者那样无所不能。  </p>
<h5 id="3-3-1-实现一个简单的AST-matcher"><a href="#3-3-1-实现一个简单的AST-matcher" class="headerlink" title="3.3.1 实现一个简单的AST matcher"></a>3.3.1 实现一个简单的AST matcher</h5><p>我们看看我们如何用AST matcher来改写<code>MainCallChecker</code>：</p>
<p>首先写一个matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))). <span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>完整的检查器逻辑现在只需要写一行代码！剩下的就是编写检查程序并抛出错误报告。留神<code>bind(…)</code>命令是如何为应用它的AST节点分配名称的，以便将来参考。  </p>
<p>我们需要做的第一件事是定义匹配器回调。 每当checker找到一些东西时，就会触发这个回调。 这个回调需要继承<code>MatchFinder::MatchCallback</code>并实现名为<code>run(…)</code>的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Callback</span> : <span class="keyword">public</span> MatchFinder ::MatchCallback &#123;</span><br><span class="line">        BugReporter &amp;BR;</span><br><span class="line">        AnalysisDeclContext *ADC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">const</span> MatchFinder ::MatchResult &amp;Result)</span></span>;</span><br><span class="line">        <span class="built_in">Callback</span>(BugReporter &amp;Reporter, AnalysisDeclContext *Context)</span><br><span class="line">            : <span class="built_in">BR</span>(Reporter), <span class="built_in">ADC</span>(Context) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>理想情况下，唯一需要做的就是抛出一个错误报告。不过matcher并不能永远写清楚逻辑细节，所以留一些检查工作在回调函数中也是很正常的事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Callback::run</span><span class="params">(<span class="type">const</span> MatchFinder ::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> CallExpr *CE = Result.Nodes.<span class="built_in">getNodeAs</span>&lt;CallExpr&gt;(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(CE);</span><br><span class="line">    SourceRange R = CE-&gt;<span class="built_in">getSourceRange</span>();</span><br><span class="line">    PathDiagnosticLocation ELoc =</span><br><span class="line">        PathDiagnosticLocation ::<span class="built_in">createBegin</span>(CE, BR.<span class="built_in">getSourceManager</span>(), ADC);</span><br><span class="line">    BR.<span class="built_in">EmitBasicReport</span>(ADC-&gt;<span class="built_in">getDecl</span>(), <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;Call to main&quot;</span>, ELoc, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在回调函数中，我们拿到了call expression的名字“call”（正是我们在checker）中通过<code>bind()</code>定义的。在matcher中，我们确信这些调用表达式是存在的，所以我们可以进行断言。</p>
<p>然后该去定义checker了。这次我们试试整TU的匹配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallCheckerMatchers</span> : <span class="keyword">public</span> Checker&lt;check ::EndOfTranslationUnit&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkEndOfTranslationUnit</span><span class="params">(<span class="type">const</span> TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;B)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>最后，在回调checker中，我们需要构建matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainCallCheckerMatchers::checkEndOfTranslationUnit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;B)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    MatchFinder F;</span><br><span class="line">    <span class="function">Callback <span class="title">CB</span><span class="params">(B, AM.getAnalysisDeclContext(TU))</span></span>;</span><br><span class="line">    F.<span class="built_in">addMatcher</span>(</span><br><span class="line">        <span class="built_in">stmt</span>(<span class="built_in">hasDescendant</span>(</span><br><span class="line">            <span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))).<span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>))),</span><br><span class="line">        &amp;CB);</span><br><span class="line">    F.<span class="built_in">matchAST</span>(AM.<span class="built_in">getASTContext</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>matchAST(...)</code>方法会match整个TU的AST。至此为止，整个checker就写好了。</p>
<p>从<code>AnalysisManager</code>中获得的<code>ASTContext</code>，包含了整个程序的AST，以及关于AST的各种元信息，例如编译期间强加的特定于实现的特征（implementation-specific traits）。</p>
<h5 id="3-3-2-复用matcher"><a href="#3-3-2-复用matcher" class="headerlink" title="3.3.2 复用matcher"></a>3.3.2 复用matcher</h5><p>如果一个子特征在matcher中被重复使用，可以保存并复用。例如，下面的例子中，TypeM就是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeMatcher TypeM = <span class="built_in">templateSpecializationType</span>(). <span class="built_in">bind</span>(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">DeclarationMatcher VarDeclM = <span class="built_in">varDecl</span>(<span class="built_in">hasType</span>(TypeM)). <span class="built_in">bind</span>(<span class="string">&quot;decl&quot;</span>);</span><br><span class="line">StatementMatcher TempObjM = <span class="built_in">temporaryObjectExpr</span>(<span class="built_in">hasType</span>(TypeM )).<span class="built_in">bind</span>(<span class="string">&quot;stmt&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="3-3-3-定义定制化matcher"><a href="#3-3-3-定义定制化matcher" class="headerlink" title="3.3.3 定义定制化matcher"></a>3.3.3 定义定制化matcher</h5><p>有时，单纯组合起预定义的checker不足以实现所需的检查。在这种情况下，可以实现一个自定义AST匹配器。这只需要几行代码，很多例子可以在<code>ASTMatchers.h</code>中找到。 在checker中实现自定义的AST matcher时，需要将其放入<code>clang::ast_matchers</code>命名空间。 下面的例子定义了一个自定义声明匹配器，它匹配声明为Union而不是Struct的<code>RecordDecl</code>节点:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> clang&#123;</span><br><span class="line">    <span class="keyword">namespace</span> ast_matchers&#123;</span><br><span class="line">        <span class="built_in">AST_MATCHER</span>(RecordDecl, isUnion)&#123;</span><br><span class="line">            <span class="keyword">return</span> Node.<span class="built_in">isUnion</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-匹配特定的statement"><a href="#3-3-4-匹配特定的statement" class="headerlink" title="3.3.4 匹配特定的statement"></a>3.3.4 匹配特定的statement</h5><p>正如之前所提到的，<code>matchAST(...)</code>匹配整个TU的AST。不过有时候只想要AST的特定一部分，那么可以试试<code>match(...)</code>方法。</p>
<p>举例来说，我们试试用<code>check::ASTCodeBody</code>来实现<code>MainCallChecker</code>。不过，<code>match(...)</code>会匹配statement本身，而<code>matchAST(...)</code>会匹配自身和子statement，所以我们要修改我们的matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainCallCheckerMatchers::checkASTCodeBody</span><span class="params">(<span class="type">const</span> Decl *D,AnalysisManager &amp;AM,BugReporter &amp;BR)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    MatchFinder F;</span><br><span class="line">    <span class="function">Callback <span class="title">CB</span><span class="params">(BR, AM.getAnalysisDeclContext(D))</span></span>;</span><br><span class="line">    F.<span class="built_in">addMatcher</span>(<span class="built_in">stmt</span>(<span class="built_in">hasDescendant</span>(<span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))).<span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>))),&amp;CB);</span><br><span class="line">    F.<span class="built_in">match</span>(*(D-&gt;<span class="built_in">getBody</span>()), AM.<span class="built_in">getASTContext</span>()); <span class="comment">// wrong in original text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-常量折叠"><a href="#3-4-常量折叠" class="headerlink" title="3.4 常量折叠"></a>3.4 常量折叠</h4><p>从表达式的AST中并不容易看出它实际上代表一个常量值。一个表达式可能包含对常量变量的类型转换和引用，将其折叠为实际值是不那么容易的。 Clang中有一个现成的解决方案：只需使用Expr的<code>EvaluateAsInt(…)</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Expr *E =<span class="comment">/* some AST expression you are interested in */</span> </span><br><span class="line">    llvm::APSInt Result;</span><br><span class="line"><span class="keyword">if</span> (E-&gt;<span class="built_in">EvaluateAsInt</span>(Result, ACtx,Expr::SE_AllowSideEffects)) &#123; </span><br><span class="line">    <span class="comment">/* we managed to obtain the value of the expression */</span></span><br><span class="line">    <span class="type">uint64_t</span> IntResult = Result.<span class="built_in">getLimitedValue</span>();   <span class="comment">/* ... */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">/* the expression doesn ’t fold to into a constant value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-延伸阅读"><a href="#3-5-延伸阅读" class="headerlink" title="3.5 延伸阅读"></a>3.5 延伸阅读</h4><p><a target="_blank" rel="noopener" href="http://llvm.org/devmtg/2013-04/videos/klimek-vhres.mov">http://llvm.org/devmtg/2013-04/videos/klimek-vhres.mov</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LibASTMatchersReference.html">http://clang.llvm.org/docs/LibASTMatchersReference.html</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Stmt.html">http://clang.llvm.org/doxygen/classclang_1_1Stmt.html</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Decl.html">http://clang.llvm.org/doxygen/classclang_1_1Decl.html</a></p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Type.html">http://clang.llvm.org/doxygen/classclang_1_1Type.html</a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH2/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-25 17:14:18 / Modified: 17:14:36" itemprop="dateCreated datePublished" datetime="2022-04-25T17:14:18+08:00">2022-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH2-checker的分类-lt-gt-程序的表示方法"><a href="#CH2-checker的分类-lt-gt-程序的表示方法" class="headerlink" title="CH2 checker的分类 &lt;-&gt; 程序的表示方法"></a>CH2 checker的分类 &lt;-&gt; 程序的表示方法</h3><p>在开发一个checker之前，你首先要确定，是需要一个path-sensitive的checker，还是只在语法层面检查就够了。</p>
<p>path-sensitive的检查通常比编译本身要慢很多倍；这其中，绝大多数时间消耗是因为内核需要构建必要的数据结构。checker本身通常意义上是轻量的，除非其中包含了过大过重的运算量。所以，需要抉择的是「是否引入path-sensitive的checker」，而不需要在之后考虑「再引入一个path-sensitive的checker会有多大负担」。</p>
<p>与之相对，如果只是检查语法(syntax)，会和编译过程一样迅速，甚至更快（因为不需要产生目标代码），不过收集的可用信息也会更少。</p>
<p>想要理解这两种checker的区别，最简单的就是看它们是如何表示程序本身的。</p>
<p>我们以下面这段代码为例，从其对应的AST(Abstract-Syntax-Tree, 抽象语法树)，CFG(Control-Flow-Graph, 控制流图)，EG(Exploded-Graph, 爆炸图)来深入探讨：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y, z;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        y = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        z = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-抽象语法树（Abstract-Syntax-Tree）"><a href="#2-1-抽象语法树（Abstract-Syntax-Tree）" class="headerlink" title="2.1 抽象语法树（Abstract Syntax Tree）"></a>2.1 抽象语法树（Abstract Syntax Tree）</h4><p>clang的抽象语法树是由编译器前端生成的一种结构，是一种程序的中间表示（IR, Intermediate Representation）。二进制代码生成是在AST上进行的。与GCC的C&#x2F;C++ 编译器所产生的AST不同，clang的AST不仅有正确编译程序所必要的信息，还有关于程序源码的完整信息，包括：每个树上的元素在源代码里的位置、在原代码中是如何撰写的（甚至预处理之前是如何撰写的）。这使得AST可以作为源代码层面分析程序的易用框架。</p>
<p>以下是test.c的AST:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ clang-7 -cc1 -ast-dump /tmp/foo.cpp</span><br><span class="line">TranslationUnitDecl 0x32173f8 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt;</span><br><span class="line">|-TypedefDecl 0x3217cd0 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __int128_t <span class="string">&#x27;__int128&#x27;</span></span><br><span class="line">| `-BuiltinType 0x3217990 <span class="string">&#x27;__int128&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3217d38 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __uint128_t <span class="string">&#x27;unsigned __int128&#x27;</span></span><br><span class="line">| `-BuiltinType 0x32179b0 <span class="string">&#x27;unsigned __int128&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3218078 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __NSConstantString <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">| `-RecordType 0x3217e20 <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">|   `-CXXRecord 0x3217d88 <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">|-TypedefDecl 0x32517e0 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_ms_va_list <span class="string">&#x27;char *&#x27;</span></span><br><span class="line">| `-PointerType 0x32180d0 <span class="string">&#x27;char *&#x27;</span></span><br><span class="line">|   `-BuiltinType 0x3217490 <span class="string">&#x27;char&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3251b18 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_va_list <span class="string">&#x27;__va_list_tag [1]&#x27;</span></span><br><span class="line">| `-ConstantArrayType 0x3251ac0 <span class="string">&#x27;__va_list_tag [1]&#x27;</span> 1 </span><br><span class="line">|   `-RecordType 0x32518d0 <span class="string">&#x27;__va_list_tag&#x27;</span></span><br><span class="line">|     `-CXXRecord 0x3251830 <span class="string">&#x27;__va_list_tag&#x27;</span></span><br><span class="line">`-FunctionDecl 0x3251c40 &lt;/tmp/foo.cpp:1:1, line:7:1&gt; line:1:6 foo <span class="string">&#x27;void (int)&#x27;</span></span><br><span class="line">  |-ParmVarDecl 0x3251b80 &lt;col:10, col:14&gt; col:14 used x <span class="string">&#x27;int&#x27;</span></span><br><span class="line">  `-CompoundStmt 0x3252098 &lt;col:16, line:7:1&gt;</span><br><span class="line">    |-DeclStmt 0x3251e30 &lt;line:2:5, col:13&gt;</span><br><span class="line">    | |-VarDecl 0x3251d40 &lt;col:5, col:9&gt; col:9 used y <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | `-VarDecl 0x3251db8 &lt;col:5, col:12&gt; col:12 used z <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    |-IfStmt 0x3251f40 &lt;line:3:5, line:4:13&gt;</span><br><span class="line">    | |-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">    | |-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br><span class="line">    | |-BinaryOperator 0x3251ea8 &lt;line:3:8, col:13&gt; <span class="string">&#x27;bool&#x27;</span> <span class="string">&#x27;==&#x27;</span></span><br><span class="line">    | | |-ImplicitCastExpr 0x3251e90 &lt;col:8&gt; <span class="string">&#x27;int&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class="line">    | | | `-DeclRefExpr 0x3251e48 &lt;col:8&gt; <span class="string">&#x27;int&#x27;</span> lvalue ParmVar 0x3251b80 <span class="string">&#x27;x&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | | `-IntegerLiteral 0x3251e70 &lt;col:13&gt; <span class="string">&#x27;int&#x27;</span> 0</span><br><span class="line">    | |-BinaryOperator 0x3251f18 &lt;line:4:9, col:13&gt; <span class="string">&#x27;int&#x27;</span> lvalue <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    | | |-DeclRefExpr 0x3251ed0 &lt;col:9&gt; <span class="string">&#x27;int&#x27;</span> lvalue Var 0x3251d40 <span class="string">&#x27;y&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | | `-IntegerLiteral 0x3251ef8 &lt;col:13&gt; <span class="string">&#x27;int&#x27;</span> 5</span><br><span class="line">    | `-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">    `-IfStmt 0x3252060 &lt;line:5:5, line:6:13&gt;</span></span><br><span class="line"><span class="string">      |-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br><span class="line">      |-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">      |-UnaryOperator 0x3251fd0 &lt;line:5:8, col:9&gt; &#x27;bool&#x27; prefix &#x27;!&#x27; cannot overflow</span></span><br><span class="line"><span class="string">      | `-ImplicitCastExpr 0x3251fb8 &lt;col:9&gt; &#x27;bool&#x27; &lt;IntegralToBoolean&gt;</span></span><br><span class="line"><span class="string">      |   `-ImplicitCastExpr 0x3251fa0 &lt;col:9&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span></span><br><span class="line"><span class="string">      |     `-DeclRefExpr 0x3251f78 &lt;col:9&gt; &#x27;int&#x27; lvalue ParmVar 0x3251b80 &#x27;x&#x27; &#x27;int&#x27;</span></span><br><span class="line"><span class="string">      |-BinaryOperator 0x3252038 &lt;line:6:9, col:13&gt; &#x27;int&#x27; lvalue &#x27;=&#x27;</span></span><br><span class="line"><span class="string">      | |-DeclRefExpr 0x3251ff0 &lt;col:9&gt; &#x27;int&#x27; lvalue Var 0x3251db8 &#x27;z&#x27; &#x27;int&#x27;</span></span><br><span class="line"><span class="string">      | `-IntegerLiteral 0x3252018 &lt;col:13&gt; &#x27;int&#x27; 6</span></span><br><span class="line"><span class="string">      `-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>阅读AST的过程与阅读源程序是很类似的，注释中标明了很多源代码上不那么明显可见的语义（semantic）。例如，你可以直接读出，第3行的x是作为foo(…)函数的参数传入的，而第4行的y是一个在第2行声明的局部变量。</p>
<p>不过，在构造AST的过程中，编译器并不会试图理解或建模程序究竟在做什么。它不会构建不同分支选择所导致的不同的程序路径，更不会去试图预测不同的分支会发生什么。</p>
<p>基于AST能做的最好的事情莫过于检测不想要的代码模式（code pattern）。例如，可能我们在某个项目中不允许C风格的强制类型转换。那么我们就可以在语法树上所有的C风格强制类型转换节点上报警。更复杂一点的例子，比如“要求所有函数的返回值都应当进行检验”。</p>
<p>在CSA的默认发行版中，<code>security.InsecureAPI</code>分类中的许多checker都是AST checker的好例子。</p>
<p>不过，如果你想要检查点复杂的情况，AST checker的能力没有那么强。比如说在检查除零时，它可以检查出<code>y = x / 0;</code> 但很难查出<code>z=0; ...y = x/z;</code> 这种时候，就需要一些更强力的工具了。</p>
<h4 id="2-2-控制流图（Control-Flow-Graph）"><a href="#2-2-控制流图（Control-Flow-Graph）" class="headerlink" title="2.2 控制流图（Control Flow Graph）"></a>2.2 控制流图（Control Flow Graph）</h4><p>控制流图使用图来表示程序执行中所有可能经过的路径。CFG 是为每个函数体单独构造的，每一个节点代表一个内部不包含任何分支的基本语句块（这意味着其中是顺序执行的）。每个基本块以“终结语句”结束，“终结语句”要么是一个分支语句，要么是函数的return。这个基本块的出边会连到根据“终结语句”的条件判断可达的其它基本语句块。</p>
<p>CSA中有一个简单的输出CFG的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$clang</span> -cc1 -analyze -analyzer-checker=debug.DumpCFG test.c</span><br></pre></td></tr></table></figure>



<p>或者（需要Graphviz，生成dot图，且需要DEBUG的clang）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./bin/clang  -cc1 -analyze -analyzer-checker=debug.ViewCFG -analyzer-viz-egraph-graphviz test.C</span><br><span class="line"><span class="variable">$dot</span> xxxx.dot -Tpng -o test.png</span><br></pre></td></tr></table></figure>



<p>这里是源码意义上的CFG。如果想要查看中间码的CFG，可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$clang</span> -S -emit-llvm test.c -o test.bc</span><br><span class="line"><span class="variable">$opt</span> -view-cfg test.bc</span><br><span class="line"><span class="variable">$dot</span> xxxx.dot -Tpng -o test.png</span><br></pre></td></tr></table></figure>



<p>基于CFG的分析有利于创建旨在做安全检查的checker，尤其是那些需要考虑程序所有的可能路径的。举例来说，如果你想要确保某个特定的分支条件永远算出来是<code>false</code>，使得其下的某些代码是不可达的，那么你将不得不接触这个条件中的每一个变量的定义——这时候，CFG就恰是你所需要的。</p>
<p>CFG可以很容易从AST构建。但是，基于CFG的分析通常不是很容易实现，因为CFG并不提供实时的数据流分析。为了达到这个目的，需要写额外的代码。Clang框架本身提供了一些“开箱即用”的基于CFG的checker，例如<code>LivenessAnalysis</code> （这也是CSA内存模型中的关键一点）。</p>
<p>在CSA的默认发行版中，<code>deadcode.DeadStores</code>是一个很好的基于CFG的checker的例子。</p>
<p>有时候，基于CFG的分析会和path-sensitive的分析组合使用：用path-sensitive的部分来检查潜在的缺陷位置，再用基于CFG的启发式算法来检查相连的其他路径以提高真阳性率（True Positive Rate）。<code>deadcode.UnreachableCode</code>就是一个结合path-sensitive和CFG的很好例子。</p>
<p>但是，细心的读者会在foo()函数的CFG中迅速发现一个缺陷：CFG无法显示分支条件的相关性。实际上<code>x==0</code>和<code>!x</code>的真值是相同的，故而两个分支条件注定同真或同假，所以从程序开始达到结尾实际上只存在两条路径：</p>
<ul>
<li>要么<code>x==0</code>，串行执行整个代码给y、z赋值。</li>
<li>要么<code>x!=0</code>，直接跳转到结尾。</li>
</ul>
<h4 id="2-3-爆炸图（Exploded-Graph）"><a href="#2-3-爆炸图（Exploded-Graph）" class="headerlink" title="2.3 爆炸图（Exploded Graph）"></a>2.3 爆炸图（Exploded Graph）</h4><p>CSA的爆炸图是path-sensitive分析器引擎的基础数据结构。分析器核心试图“解释”程序代码，并分别处理通过CFG的所有不同路径（即使它们通过相同的语句或基本语句块），因此叫作“爆炸”（explode）。 爆炸图包含所有由分析器引擎探索过的路径，并保有每个语句中每个路径上的程序状态的信息。图中的每个点（我们称作“爆炸点”），是一个二元组：<code>（程序当前状态，当前被分析的程序节点）</code>。</p>
<p>你可以这样使用这个checker来查看爆炸图：</p>
<p><code>clang -cc1 -analyze -analyzer-checker=debug.ViewExplodedGraph test.c</code></p>
<p>实际上，爆炸图通常很大很大，例如<code>foo()</code>产生的爆炸图会有超过50个节点。当到达一个CFG中的终结符时，比如一个if语句，因为不确定条件判断的结果，所以并不知道会走向哪条分支。在爆炸图中，就会兵分两路，在每条路上，都假定进入该条路的条件成立。例如<code>if(x)</code>中，<code>then-branch</code>的条件是<code>x ∈ [0,0]</code>，而<code>else-branch</code>的条件是<code> x ∈ [INT_MIN,-1] ∪ [1, INT_MAX]</code>。这个条件会被收集起来，直到这个符号达到生命周期的尽头。</p>
<p>例如，在已经收集了<code>x==0</code>条件的前提下，<code>!x</code>的真值是可判定的，而不再是一个未定值。而此时关于<code>y</code>的信息则因为y已经到达生命周期的尽头而不再存储。</p>
<p>爆炸图中存储了详尽的信息，包含分析器核心对程序执行所能做出的”最佳假设”。 此外，与基于AST和CFG的分析不同，path-sensitive的CSA checker很少被动地读取爆炸图，而是积极地参与其构建，添加自己的节点、绑定(binding)、假设、作特定于检查器的标记，并根据自己的意愿在分解图中分隔路径。</p>
<h4 id="2-4-延伸阅读"><a href="#2-4-延伸阅读" class="headerlink" title="2.4 延伸阅读"></a>2.4 延伸阅读</h4><p>关于AST：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html">https://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH1/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-25 11:59:45 / Modified: 12:04:45" itemprop="dateCreated datePublished" datetime="2022-04-25T11:59:45+08:00">2022-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH-1-关于CSA-Clang-Static-Analyzer-的简介"><a href="#CH-1-关于CSA-Clang-Static-Analyzer-的简介" class="headerlink" title="CH 1 关于CSA(Clang Static Analyzer)的简介"></a>CH 1 关于CSA(Clang Static Analyzer)的简介</h3><p>以LLVM的体系结构为基础，Clang编译器的功能远远不只是一个将C&#x2F;C++&#x2F;Obj-C代码转换成二进制可执行文件那么简单。Clang允许用户在编译过程上“挂钩”，并借此得到编译器在编译的每个阶段所产生的数据的详细信息。换句话说，如果你想了解更多关于你写的程序的信息，那么最好就直接去问编译器——而clang是愿意回答你的问题的，前提是你问了正确的问题。</p>
<p>clang工具的应用之一，是自动寻找程序中的缺陷，并提供警告。很多警告是你的编译器本身可能不会提供的。比如说，<code>clang-tidy</code>会通过检查程序中的语法来寻找代码风格、安全性或可移植性上的问题。</p>
<p>CSA是另一个寻找程序缺陷的工具。在源码基础上，CSA会在不编译的基础上虚拟执行程序中的一部分（就如同阅读源码并想象如果跑起来是什么样），并报告那些虚拟执行中出现的问题。因为任何真实程序的实际行为都取决于外部因素，例如输入值、随机数和库组件的行为(对于这些因素，源代码并不总是可获取的)，所以分析器引擎用<strong>代数符号</strong>表示未知值，并基于这些符号进行符号计算，并得出导致程序出错的对应符号值条件。  </p>
<p>因此，CSA能够发现罕见的程序路径上的深层次bug。 这些路径极容易被手动测试人员或自动化测试套件忽略。一旦发现了一个bug，分析器就会绘制出导致这个bug的整条path，并在每个条件语句上标出跳转方向。  </p>
<p>不过需要注意的是，分析器只能找到那些定制去找的bug。 如果没有定制的话，即使遇到问题，分析也只会进一步进行，不会报告。 对于分析器发现的每一种特定类型的缺陷，例如空指针的解引用或缓冲区溢出，都存在一个特殊的模块(checker)，使得分析器在分析期间对此类缺陷作出响应。</p>
<p>因此，从本质上讲，分析器核心负责以符号方式执行程序，而checker订阅它们感兴趣的事件、检查基于符号值的假设是否满足、并在不满足的时候发出警告。</p>
<p>这意味着不仅可以使用分析器本身来发现缺陷，而且还可以使它适应特定的项目。 例如，可以定制自己的强制规则，或者发现特定库API的误用。为了做到这一点，需要分析器编写一个新的检查器模块。这不太困难，因为CSA是一个非常容易的工具，而这个指南应该能够帮到你。</p>
<h4 id="1-1-从写一个简单的checker上手"><a href="#1-1-从写一个简单的checker上手" class="headerlink" title="1.1 从写一个简单的checker上手"></a>1.1 从写一个简单的checker上手</h4><p>作为开始，我们先写一个极简的checker，检查C++标准中的这一条：</p>
<blockquote>
<p>basic.start.main.c : main()函数在程序中不应当被使用</p>
</blockquote>
<p>换言之，<code>main()</code>函数不应当是递归的，程序永远不应该调用<code>main()</code>，否则将是一个UB(Undefined Behavior)。寻找这个错误的过程听起来比较简单，就是在程序中寻找是否存在名字为”main”的函数调用。要出现这种错误，变成这需要不小心把一个指向main函数的指针放进了变量，把指针传了传，并最终不小心调用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example_Test.c</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*<span class="type">main_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> **)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">main_t</span> foo = main;</span><br><span class="line">    <span class="type">int</span> exit_code = <span class="built_in">foo</span>(argc, argv); <span class="comment">// actually calls main()</span></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使在这个简单的例子中，分析器的path-sensitive引擎相比较简单的语法检查也有不小的优势。让我们来看看CSA是如何检查的。</p>
<p>实际上，即使把main函数赋值给一个指针也算是对main函数的一种“使用”。但这里出于教学意义，我们会找出它是否真的被使用了：</p>
<p>第一步，我们来把这个checker的定义加到checker列表里。在clang的文件树里打开<code>lib/StaticAnalyzer/Checkers/Checkers.td</code>，并找个地方增加一个对checker的描述，例如在<code>alpha.core</code>分类里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MainCallChecker</span> : Checker &lt;<span class="string">&quot; MainCall&quot;</span>&gt;,</span><br><span class="line">    HelpText &lt;<span class="string">&quot;Check for calls to main&quot;</span>&gt;,</span><br><span class="line">    DescFile &lt;<span class="string">&quot; MainCallChecker.cpp&quot;</span>&gt;;    </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在重新编译clang以后，我们写的checker就应该出现在了clang的checker列表里。使用<code>clang -cc1 -analyzer-checker-help</code> 可以查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ $ clang -cc1 -analyzer -checker -<span class="built_in">help</span> </span><br><span class="line">OVERVIEW: Clang Static Analyzer Checkers List </span><br><span class="line">USAGE: -analyzer -checker &lt;CHECKER or PACKAGE ,...&gt;</span><br><span class="line">CHECKERS: </span><br><span class="line">...</span><br><span class="line">alpha.core.MainCall     Check <span class="keyword">for</span> calls to main</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个例子中，”alpha.core.MainCallChecker” 就是我们注册的checker的名字。一旦checker被注册了，它就可以通过CSA的命令行选项来启用，描述也会显示在help里。”alpha.core”是checker的分类名，例如，<code>-analyzer-checker alpha.core</code>会启用这个分类中的所有checker。</p>
<p>第二步，我们把checker的代码加入构建过程中：在<code>lib/StaticAnalyzer/Checkers/CMakeLists.txt</code>里，添加checker文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">MainCallChecker.cpp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，在checker文件里添加功能代码，我们之后会详细解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClangSACheckers.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/BugReporter/BugType.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/Checker.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallChecker</span> : <span class="keyword">public</span> Checker &lt;check::PreCall &gt; &#123; </span><br><span class="line">        <span class="keyword">mutable</span> std::unique_ptr &lt;BugType &gt; BT;    </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call , CheckerContext &amp;C)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MainCallChecker :: <span class="built_in">checkPreCall</span>(<span class="type">const</span> CallEvent &amp;Call,CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = Call.<span class="built_in">getCalleeIdentifier</span> ())</span><br><span class="line">        <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT)</span><br><span class="line">            BT.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BugType</span>(<span class="keyword">this</span> , <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>)); </span><br><span class="line">            ExplodedNode *N = C.<span class="built_in">generateErrorNode</span>();</span><br><span class="line">        	<span class="keyword">auto</span> Report = llvm:: make_unique &lt;BugReport &gt;(*BT, BT -&gt;<span class="built_in">getName</span>(), N);</span><br><span class="line">            C.<span class="built_in">emitReport</span>(std::<span class="built_in">move</span>(Report ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ento:: <span class="built_in">registerMainCallChecker</span>(CheckerManager &amp;Mgr) &#123; </span><br><span class="line">    Mgr.registerChecker &lt;MainCallChecker &gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译clang之后，你就可以运行CSA、启用这个checker，并且看到结果了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ $ clang -cc1 -analyze -analyzer -checker=alpha.core Example_Test.c Example_Test.c:4:19: warning: Call to main</span><br><span class="line">int exit_code = foo(argc , argv); // actually calls main ()! </span><br><span class="line">				^~~~~~~~~~~~~~~</span><br><span class="line">1 warning generated</span><br></pre></td></tr></table></figure>

<h4 id="1-2-样例checker代码注解"><a href="#1-2-样例checker代码注解" class="headerlink" title="1.2 样例checker代码注解"></a>1.2 样例checker代码注解</h4><p>现在我们来看看<code>MainCallChecker</code>内部是如何工作的。<code>MainCallChecker</code>是一个path-snesitive的checker，它可以检测在不同的程序路径下，“流经”不同变量的值，并分析出所执行的路径是哪条，这点我们在前面的样例中已经提及。</p>
<h5 id="1-2-1-声明一个checker类"><a href="#1-2-1-声明一个checker类" class="headerlink" title="1.2.1 声明一个checker类"></a>1.2.1 声明一个checker类</h5><p>CSA中，checker的实现是通过继承类模板<code>Checker&lt;...&gt;</code>的，模板的参数表明了哪些回调函数是checker所订阅的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallChecker</span> : <span class="keyword">public</span> Checker &lt;check::PreCall &gt; &#123; </span><br><span class="line">        <span class="keyword">mutable</span> std::unique_ptr &lt;BugType &gt; BT;    </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call , CheckerContext &amp;C)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Checker类定义通常被放进匿名的命名空间来避免不同的checker同时被装载进CSA的时候发生名称冲突。</p>
<p><code>MainCallChecker</code>订阅了<code>checker::PreCall</code>这个事件。在每一次CSA的引擎遇到一个函数调用时，在进一步分析它之前就会调用在Checker中定义的<code>CheckPreCall()</code>回调函数。</p>
<h5 id="1-2-2-实现checker的回调函数"><a href="#1-2-2-实现checker的回调函数" class="headerlink" title="1.2.2 实现checker的回调函数"></a>1.2.2 实现checker的回调函数</h5><p>现在我们来看看<code>checkPreCall(...)</code>这个回调函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MainCallChecker :: <span class="built_in">checkPreCall</span>(<span class="type">const</span> CallEvent &amp;Call,CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = Call.<span class="built_in">getCalleeIdentifier</span> ())</span><br><span class="line">        <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT)</span><br><span class="line">            BT.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BugType</span>(<span class="keyword">this</span> , <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>)); </span><br><span class="line">            ExplodedNode *N = C.<span class="built_in">generateErrorNode</span>();</span><br><span class="line">        	<span class="keyword">auto</span> Report = llvm:: make_unique &lt;BugReport &gt;(*BT, BT -&gt;<span class="built_in">getName</span>(), N);</span><br><span class="line">            C.<span class="built_in">emitReport</span>(std::<span class="built_in">move</span>(Report ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数中的<code>CallEvent</code>这个结构里包含了遇到函数调用这个事件时所有CSA内核所收集的信息，例如关于被调用函数、实参值的信息。</p>
<p>由于我们的checker是path-sensitive的，我们能得到的信息比直接看语法树要多很多。具体来说，即使用函数指针它也能知道被调用对象，因为CSA内核在这条执行路径上预测了这个指针的值。</p>
<p>在函数体的第一行，我们从<code>CallEvent</code>中拿到被调用函数的标识符信息(<code>IdentifierInfo</code>)。为了以防万一，我们把它放在if条件中。</p>
<p>在第二行，我们判断我们遇到的标识符的名字是不是”main”。我们只想找以”main”为名字的函数，所以后续所有的检查都应该在这一点的基础之上。</p>
<p>检查的逻辑大概就是这样，剩下的工作就是为用户生成错误报告。</p>
<h5 id="1-2-3-抛出错误报告"><a href="#1-2-3-抛出错误报告" class="headerlink" title="1.2.3 抛出错误报告"></a>1.2.3 抛出错误报告</h5><p>为了生成错误报告，我们使用回调中的另一个对象，CheckerContext。它是一个多功能组件，checker可以使用它来获取分析信息，并改变分析流程。  </p>
<p>在checker中有一个变量BT，它存储一个“错误类型”，用于区分bug的来源。 一个检查器可能有多种错误类型; 为了提高性能，它们通常被存储在检查器中并重新使用。 在第24行，检查器将其错误类型结构BT初始化为一个名为“Call to main”的错误，在类别“示例检查器”内，除非它已经初始化。  </p>
<h5 id="1-2-4-注册checker"><a href="#1-2-4-注册checker" class="headerlink" title="1.2.4 注册checker"></a>1.2.4 注册checker</h5><p>最后，需要添加一点精妙的代码来让分析器启动的时候生成checker实例。你可以使用这部分代码来在整个TU(Translation Unit)中禁用特定的checker。以下的代码创建一个（且仅一个）<code>MainCallChecker</code>的实例来传递给将要展开的事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ento:: <span class="built_in">registerMainCallChecker</span>(CheckerManager &amp;Mgr) &#123; </span><br><span class="line">    Mgr.registerChecker &lt;MainCallChecker&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-把checker编译成一个独立的模块"><a href="#1-3-把checker编译成一个独立的模块" class="headerlink" title="1.3 把checker编译成一个独立的模块"></a>1.3 把checker编译成一个独立的模块</h4><p>前面我们已经完成了在clang内部编译checker的尝试。还有另一种方法是把checker编译成一个独立插件。这种情况下，你不需要修改<code>Checkers.td</code>和<code>CmakeLists.txt</code>来运行checker。你只需要把自己的checker编译成一个独立的库，在运行时装载它。</p>
<p>如果这样做，你的目标是把你的checker编译成一个clang的plugin。你不需要挂<code>ClangSACheckers.h</code>头，而是需要挂<code>CheckerRegistry.h</code>头:</p>
<p><code>#include &quot;clang/StaticAnalyzer/Core/CheckerRegistry.h&quot;</code></p>
<p>然后在库中定义一个外部可见的函数来动态地完成checker注册的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clang_registerCheckers</span> <span class="params">(CheckerRegistry &amp;registry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">registry.<span class="built_in">addChecker</span>&lt;MainCallChecker&gt;(<span class="string">&quot;alpha.core.MainCallChecker&quot;</span>,<span class="string">&quot;Checks for calls to main&quot;</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clang的API的版本与plugin的API的版本要保持一致（换句话说，你不能把旧版本API的插件装载进新版本clang里）。所以说，checker需要保存它的版本信息在一个外部可见的变量<code>clang_analyzerAPIVersionString</code>中，来完成兼容性检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">const</span> <span class="type">char</span> clang_analyzerAPIVersionString[]= CLANG_ANALYZER_API_VERSION_STRING;</span><br></pre></td></tr></table></figure>

<p>当你使用<code>clang -cc1 -load YourChecker.so</code>之后，对应的Checker就会装载进列表中，并可以被激活。</p>
<h4 id="1-4-延伸阅读"><a href="#1-4-延伸阅读" class="headerlink" title="1.4 延伸阅读"></a>1.4 延伸阅读</h4><p><a target="_blank" rel="noopener" href="http://llvm.org/doxygen">http://llvm.org/doxygen</a></p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen">http://clang.llvm.org/doxygen</a></p>
<p><a target="_blank" rel="noopener" href="http://clang-analyzer.llvm.org/checker_dev_manual.html">http://clang-analyzer.llvm.org/checker_dev_manual.html</a></p>
<p><a target="_blank" rel="noopener" href="http://llvm.org/devmtg/2012-11/videos/Zaks-Rose-Checker24Hours.mp4">http://llvm.org/devmtg/2012-11/videos/Zaks-Rose-Checker24Hours.mp4</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/24/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/24/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B03/" class="post-title-link" itemprop="url">《clang 源码导读》 笔记(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-24 17:00:00" itemprop="dateCreated datePublished" datetime="2022-03-24T17:00:00+08:00">2022-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 18:04:21" itemprop="dateModified" datetime="2022-04-25T18:04:21+08:00">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-3-Clang-Driver-参数解析"><a href="#Chapter-3-Clang-Driver-参数解析" class="headerlink" title="Chapter 3 Clang Driver 参数解析"></a>Chapter 3 Clang Driver 参数解析</h2><p>关注点：</p>
<ul>
<li>各个类负责的职责</li>
<li>类之间的流程</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p><code>Info</code>：保存了<code>Option</code>信息的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Entry for a single option instance in the option data table.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="comment">/// A null terminated array of prefix strings to apply to name while</span></span><br><span class="line">    <span class="comment">/// matching.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> *Prefixes;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *HelpText;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *MetaVar;</span><br><span class="line">    <span class="type">unsigned</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Kind;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Param;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> GroupID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> AliasID;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *AliasArgs;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Option</code>： 表示驱动程序接受的选项的一种形式。每一个具体的Arg实例对应一个特定的Option实例<br>见<a target="_blank" rel="noopener" href="https://www.llvm.org/doxygen/Option_8h_source.html#l00051">https://www.llvm.org/doxygen/Option_8h_source.html#l00051</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Option - Abstract representation for a single form of driver</span></span><br><span class="line"><span class="comment">/// argument.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An Option class represents a form of option that the driver</span></span><br><span class="line"><span class="comment">/// takes, for example how many arguments the option has and how</span></span><br><span class="line"><span class="comment">/// they can be provided. Individual option instances store</span></span><br><span class="line"><span class="comment">/// additional information about what group the option is a member</span></span><br><span class="line"><span class="comment">/// of (if any), if the option is an alias, and a number of</span></span><br><span class="line"><span class="comment">/// flags. At runtime the driver parses the command line into</span></span><br><span class="line"><span class="comment">/// concrete Arg instances, each of which corresponds to a</span></span><br><span class="line"><span class="comment">/// particular Option instance.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Arg</code>：保存具体的option信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A concrete instance of a particular driver option.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The Arg class encodes just enough information to be able to</span></span><br><span class="line"><span class="comment">/// derive the argument values efficiently.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OptTable</code>：提供了“一层”隔离，在保存足够信息的同时，尽可能lazily-created <code>Option</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Provide access to the Option info table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The OptTable class provides a layer of indirection which allows Option</span></span><br><span class="line"><span class="comment">/// instance to be created lazily. In the common case, only a few options will</span></span><br><span class="line"><span class="comment">/// be needed at runtime; the OptTable class maintains enough information to</span></span><br><span class="line"><span class="comment">/// parse command lines without instantiating Options, while letting other</span></span><br><span class="line"><span class="comment">/// parts of the driver still use Option instances where convenient.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>InputArgList</code>：保留输入的原始参数和解析后的参数列表，是ArgList的子类</p>
</li>
<li><p><code>DriverOptTable</code> 记录driver相关的info信息，是OptTable的子类</p>
</li>
</ul>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="DriverOptTable"><a href="#DriverOptTable" class="headerlink" title="DriverOptTable"></a>DriverOptTable</h5><p>是OptTable的子类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/23/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B02/" class="post-title-link" itemprop="url">《clang 源码导读》 笔记(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-23 17:00:00" itemprop="dateCreated datePublished" datetime="2022-03-23T17:00:00+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 18:04:11" itemprop="dateModified" datetime="2022-04-25T18:04:11+08:00">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter2-Clang-Driver及总体流程"><a href="#Chapter2-Clang-Driver及总体流程" class="headerlink" title="Chapter2 Clang Driver及总体流程"></a>Chapter2 Clang Driver及总体流程</h3><p>供参考的链接：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/DriverInternals.html#low-overhead">https://clang.llvm.org/docs/DriverInternals.html#low-overhead</a></p>
<p>代码的位置：<code>clang/driver/Driver.h</code></p>
<h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul>
<li>clang driver 的整体流程</li>
<li>PipeLine分为哪几步？</li>
</ul>
<h4 id="clang-driver-流程"><a href="#clang-driver-流程" class="headerlink" title="clang-driver 流程"></a>clang-driver 流程</h4><p>前面介绍过，clang driver本身是一个“驱动”器，并不负责真正的编译工作，而是组装指令（无论是编译器的还是ld的命令）。</p>
<p>clang driver的处理流程分为若干阶段：解析参数（Parse） -&gt; 构造编译流水线（Pipeline） -&gt; 选择工具和文件名（Bind）-&gt;  转换参数（Translation）-&gt; 调用工具执行任务（Execute）。整体流程如下：</p>
<p><img src="https://clang.llvm.org/docs/_images/DriverArchitecture.png" alt="Driver Architecture Diagram"></p>
<p>以下简单介绍每个步骤。</p>
<h5 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h5><p>解析输入的命令行参数，生成参数列表（arglist），无须赘述。</p>
<h5 id="PipeLine"><a href="#PipeLine" class="headerlink" title="PipeLine"></a>PipeLine</h5><p>根据输入的文件和类型，构建出一系列的action。</p>
<p>借助<code>clang -ccc-print-phases</code> 可以查看action。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang-7 -ccc-print-phases t0.c</span><br><span class="line">0: input, &quot;t0.c&quot;, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line"></span><br><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang-7 -c -ccc-print-phases t0.c</span><br><span class="line">0: input, &quot;t0.c&quot;, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line"></span><br><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang -S -ccc-print-phases t0.c</span><br><span class="line">0: input, &quot;t0.c&quot;, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line"></span><br><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang -emit-llvm -S -ccc-print-phases t0.c</span><br><span class="line">0: input, &quot;t0.c&quot;, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, ir</span><br><span class="line"></span><br><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang -E -ccc-print-phases t0.c</span><br><span class="line">0: input, &quot;t0.c&quot;, c</span><br><span class="line">1: preprocessor, &#123;0&#125;, cpp-output</span><br></pre></td></tr></table></figure>

<p>可见，<code>-c</code>指令到assembler就中止了，并没有最后的link步骤，而<code>-S</code>则进一步缺少了IR之后的汇编步骤。<code>-emit-llvm</code>会停留在生成IR， <code>-E</code>则是仅进行预处理。</p>
<p>关于action的步骤，有一张图可以参考：</p>
<p><img src="https://pic2.zhimg.com/80/v2-15d13d5b18dc0aa8477189ef24f6cf8d_720w.jpg" alt="img"></p>
<h5 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h5><p>对于不同的action，选择对应的工具和文件名。</p>
<p>借助<code>clang -ccc-print-bindings</code>可以查看对应的工具和文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang-7 -ccc-print-bindings   t0.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;x86_64-pc-linux-gnu&quot;</span> - <span class="string">&quot;clang&quot;</span>, inputs: [<span class="string">&quot;t0.c&quot;</span>], output: <span class="string">&quot;/tmp/t0-47c0f3.o&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;x86_64-pc-linux-gnu&quot;</span> - <span class="string">&quot;GNU::Linker&quot;</span>, inputs: [<span class="string">&quot;/tmp/t0-47c0f3.o&quot;</span>], output: <span class="string">&quot;a.out&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>例如这里，编译所采用的工具是clang（作为编译器的clang，即clang -cc1），而linker采用的是GNU的linker。</p>
<h5 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h5><p>根据编译参数，为每个tool生成参数。</p>
<p>借助<code>-###</code>选项可以查看内部的指令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dyb@DESKTOP-JNDKOVB:~/clang_source_tests$ clang-7 -### t0.c</span><br><span class="line">clang version 7.0.1-12 (tags/RELEASE_701/final)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line"> &quot;/usr/lib/llvm-7/bin/clang&quot; &quot;-cc1&quot; &quot;-triple&quot; &quot;x86_64-pc-linux-gnu&quot; &quot;-emit-obj&quot; &quot;-mrelax-all&quot; &quot;-disable-free&quot; &quot;-disable-llvm-verifier&quot; &quot;-discard-value-names&quot; &quot;-main-file-name&quot; &quot;t0.c&quot; &quot;-mrelocation-model&quot; &quot;static&quot; &quot;-mthread-model&quot; &quot;posix&quot; &quot;-mdisable-fp-elim&quot; &quot;-fmath-errno&quot; &quot;-masm-verbose&quot; &quot;-mconstructor-aliases&quot; &quot;-munwind-tables&quot; &quot;-fuse-init-array&quot; &quot;-target-cpu&quot; &quot;x86-64&quot; &quot;-dwarf-column-info&quot; &quot;-debugger-tuning=gdb&quot; &quot;-resource-dir&quot; &quot;/usr/lib/llvm-7/lib/clang/7.0.1&quot; &quot;-internal-isystem&quot; &quot;/usr/local/include&quot; &quot;-internal-isystem&quot; &quot;/usr/lib/llvm-7/lib/clang/7.0.1/include&quot; &quot;-internal-externc-isystem&quot; &quot;/usr/include/x86_64-linux-gnu&quot; &quot;-internal-externc-isystem&quot; &quot;/include&quot; &quot;-internal-externc-isystem&quot; &quot;/usr/include&quot; &quot;-fdebug-compilation-dir&quot; &quot;/home/dyb/clang_source_tests&quot; &quot;-ferror-limit&quot; &quot;19&quot; &quot;-fmessage-length&quot; &quot;120&quot; &quot;-fobjc-runtime=gcc&quot; &quot;-fdiagnostics-show-option&quot; &quot;-fcolor-diagnostics&quot; &quot;-o&quot; &quot;/tmp/t0-25b43e.o&quot; &quot;-x&quot; &quot;c&quot; &quot;t0.c&quot; &quot;-faddrsig&quot;</span><br><span class="line"> &quot;/usr/bin/ld&quot; &quot;--build-id&quot; &quot;--eh-frame-hdr&quot; &quot;-m&quot; &quot;elf_x86_64&quot; &quot;-dynamic-linker&quot; &quot;/lib64/ld-linux-x86-64.so.2&quot; &quot;-o&quot; &quot;a.out&quot; &quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crt1.o&quot; &quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o&quot; &quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/crtbegin.o&quot; &quot;-L/usr/bin/../lib/gcc/x86_64-linux-gnu/9&quot; &quot;-L/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu&quot; &quot;-L/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../lib64&quot; &quot;-L/lib/x86_64-linux-gnu&quot; &quot;-L/lib/../lib64&quot; &quot;-L/usr/lib/x86_64-linux-gnu&quot; &quot;-L/usr/lib/../lib64&quot; &quot;-L/usr/lib/x86_64-linux-gnu/../../lib64&quot; &quot;-L/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../..&quot; &quot;-L/usr/lib/llvm-7/bin/../lib&quot; &quot;-L/lib&quot; &quot;-L/usr/lib&quot; &quot;/tmp/t0-25b43e.o&quot; &quot;-lgcc&quot; &quot;--as-needed&quot; &quot;-lgcc_s&quot; &quot;--no-as-needed&quot; &quot;-lc&quot; &quot;-lgcc&quot; &quot;--as-needed&quot; &quot;-lgcc_s&quot; &quot;--no-as-needed&quot; &quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/crtend.o&quot; &quot;/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o&quot;</span><br></pre></td></tr></table></figure>

<p>例如这里：</p>
<p>给到<code>clang -cc1</code>的参数：<code>-triple x86_64-pc-linux-gnu ...</code> 。对应Triple中<code>Arc+Vend+OS</code>的结构。</p>
<p>给到<code>ld</code>的参数：<code>--build-id --eh-frame-hdr ... -o  a.out </code>。</p>
<h5 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h5><p>实际创建进线程，调用不同tool，根据翻译出的参数，执行不同的任务。</p>
<h3 id="clang的流程"><a href="#clang的流程" class="headerlink" title="clang的流程"></a>clang的流程</h3><p>在调用”clang”的过程中，发生的流程大致为：</p>
<ul>
<li>clang 以driver身份被调用</li>
<li>clang driver根据传入的参数创建job，例如“编译任务”, “链接任务”</li>
<li>创建进程，执行对应的job</li>
</ul>
<p>实际流程：</p>
<ul>
<li><p>main先创建诊断信息（Diagnostic）实例。</p>
</li>
<li><p>随后创建Driver实例负责后续任务：</p>
<ul>
<li><p>使用Driver中的<code>BuildCompilation</code>生成需要执行的命令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// BuildCompilation - Construct a compilation object for a command</span></span><br><span class="line"><span class="comment">/// line argument vector.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \return A compilation, or 0 if none was built for the given</span></span><br><span class="line"><span class="comment">/// argument vector. A null return value does not necessarily</span></span><br><span class="line"><span class="comment">/// indicate an error condition, the diagnostics should be queried</span></span><br><span class="line"><span class="comment">/// to determine if an error occurred.</span></span><br><span class="line"><span class="function">Compilation *<span class="title">BuildCompilation</span><span class="params">(ArrayRef&lt;<span class="type">const</span> <span class="type">char</span> *&gt; Args)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>ParseArgString()</code>解析参数</li>
<li>调用<code>LoadConfigFile()</code>解析配置文件</li>
<li>调用<code>ComputeTargetTriple()</code>，获得triple</li>
<li>根据triple获得对应的ToolChain。</li>
<li>创建<code>compilation</code>。</li>
<li>通过<code>BuildInputs()</code>函数获取输入文件(因为driver可以同时编译多个源码文件)，依据是扩展名”.m”。</li>
<li>通过<code>BuildUniversalActions</code>构建JobAction。</li>
<li>通过<code>BuildJobs</code>构建<code>Jobs</code></li>
</ul>
</li>
<li><p>Driver构造完Jobs以后，会通过Driver的<code>ExecuteCompilation</code>执行命令</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/22/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">《clang 源码导读》 笔记(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-22 17:00:00" itemprop="dateCreated datePublished" datetime="2022-03-22T17:00:00+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 18:04:06" itemprop="dateModified" datetime="2022-04-25T18:04:06+08:00">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter-1-基础概念"><a href="#Chapter-1-基础概念" class="headerlink" title="Chapter 1 基础概念"></a>Chapter 1 基础概念</h3><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul>
<li>各副标题</li>
</ul>
<h4 id="“clang”-指的是什么"><a href="#“clang”-指的是什么" class="headerlink" title="“clang” 指的是什么"></a>“clang” 指的是什么</h4><ul>
<li>“clang driver” ：一个驱动器，负责根据简单参数生成复杂参数，并不负责实际编译过程</li>
<li>“clang -cc1”：实际的编译器，实现了编译前后端、汇编等部分</li>
<li>“clang frontend”：编译器前端，指到生成中间代码为止。</li>
</ul>
<h4 id="诊断信息"><a href="#诊断信息" class="headerlink" title="诊断信息"></a>诊断信息</h4><p>不同的处理<strong>阶段</strong>具有不同种类的诊断信息，维护在<code>clang/Basic/DiagnosticDriverKinds.inc</code>里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiagnosticDriverKinds.inc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_aix_default_altivec_abi, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;The default Altivec ABI on AIX is not yet supported, use &#x27;-mabi=vec-extabi&#x27; for the extended Altivec ABI&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_checker_incompatible_analyzer_option, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;checker cannot be enabled with analyzer option &#x27;%0&#x27; == %1&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_checker_option_invalid_input, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;invalid input for checker option &#x27;%0&#x27;, that expects %1&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_checker_option_unknown, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;checker &#x27;%0&#x27; has no option called &#x27;%1&#x27;&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_config_invalid_input, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;invalid input for analyzer-config option &#x27;%0&#x27;, that expects %1 value&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_config_multiple_values, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;analyzer-config option &#x27;%0&#x27; should contain only one &#x27;=&#x27;&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">DIAG</span>(err_analyzer_config_no_value, CLASS_ERROR, (<span class="type">unsigned</span>)diag::Severity::Error, <span class="string">&quot;analyzer-config option &#x27;%0&#x27; has a key but no value&quot;</span>, <span class="number">0</span>, SFINAE_SubstitutionFailure, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>而在<code>DiagnosticIDs.h</code>中同样维护了诊断的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiagnosticIDs.h</span></span><br><span class="line"><span class="comment">/// Used for handling and querying diagnostic IDs.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Can be used and shared by multiple Diagnostics for multiple translation units.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiagnosticIDs</span> : <span class="keyword">public</span> RefCountedBase&lt;DiagnosticIDs&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// The level of the diagnostic, after it has been through mapping.</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Level</span> &#123;</span><br><span class="line">    Ignored, Note, Remark, Warning, Error, Fatal</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<h4 id="平台信息的数据结构：llvm-Triple"><a href="#平台信息的数据结构：llvm-Triple" class="headerlink" title="平台信息的数据结构：llvm::Triple"></a>平台信息的数据结构：llvm::Triple</h4><blockquote>
<p>“helper class for autoconf configuration names”。</p>
</blockquote>
<p>Triple 指的是一个string triple：”Architecture + Vendor + OS”</p>
<p>传入的参数（例如<code>-arch</code>,<code>-target</code>等）会影响生成的triple，</p>
<h4 id="“工具链”"><a href="#“工具链”" class="headerlink" title="“工具链”"></a>“工具链”</h4><p>这是一个概念性的术语。GNU的minGW，微软的MSCV 都属于“工具链”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Asp"
      src="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
  <p class="site-author-name" itemprop="name">Asp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asp</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
