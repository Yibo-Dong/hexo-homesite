<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Good Good Study">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Good Good Study">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Asp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Good Good Study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Good Good Study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Day Day up</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/22/CSA%20Guide%20CN%20CH5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/22/CSA%20Guide%20CN%20CH5/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-22 22:00:00 / Modified: 22:00:31" itemprop="dateCreated datePublished" datetime="2022-05-22T22:00:00+08:00">2022-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CH5-符号值的层次结构"><a href="#CH5-符号值的层次结构" class="headerlink" title="CH5 符号值的层次结构"></a>CH5 符号值的层次结构</h2><p>符号值是CSA用于描述在程序符号执行期间遇到的已知和未知值的符号。CSA使用非常复杂的符号值层次结构。表示各种符号值的基本类是SVal类。它有不同的子类，代表不同种类的符号值。还有两个辅助类MemRegion和SymExpr，分别专门处理内存区域和符号表达式。</p>
<p>SymExpr类的对象常常被称为符号值(symbol)，代表未知的数值；如果在分析过程中已知一个值，则称之为具体值（concrete value）。MemRegion对象，也即“regions”，有两种用途：作为分析器内存模型中区域存储绑定的位置，以及用于表示指针值。</p>
<p>这三个类之间有很大的联系。例如，区域可以“基于”符号和具体值（例如，指针符号指向的区域，或具有已知或未知索引的数组元素的区域），符号可以“基于”区域（例如，定义为区域初始值的符号）。</p>
<p>此外，SVal分为两大类：表示左值的<code>loc</code>和右值的<code>NonLoc</code>。</p>
<table>
<thead>
<tr>
<th></th>
<th>角色</th>
<th>SVal</th>
<th>MemRegion</th>
<th>SymExpr</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用作范围约束的key</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>2</td>
<td>用作区域绑定的key</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>用作区域绑定的value</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>用作环境value</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>携带污染</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>6</td>
<td>携带元数据</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>用作元数据值</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>8</td>
<td>存储在GDM中</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
<p>这只对约束符号才有意义；具体的值是已知的，所以进一步给它们分配整数范围约束是没有意义的，而且内存区域地址并不会在编译时真正定义。当然，区域存储通过为区域指定任意值来工作，而环境通过为AST表达式指定任意值来工作。</p>
<p>表格里的第五行可能出乎你的意料，如上所述，我们一直在讨论受污染的存储区域，一些处理受污染内存区域的方法会接受任意的<code>SVal</code>。然而，当受污染分析处理符号以外的值时，它只会试图在其中找到符号值，这点我们将在第5.6小节中详细讨论。元数据符号的概念将在后面的5.5.5中讨论。最后，GDM几乎可以承载任何东西，这就是“G”的含义。</p>
<h4 id="5-1-构建符号值"><a href="#5-1-构建符号值" class="headerlink" title="5.1 构建符号值"></a>5.1 构建符号值</h4><p><code>SValBuilder</code>类提供了构造<code>SVal</code>对象的方法。它允许构造各种<code>SVal</code>和各种<code>SymExpr</code>（必要时将后者表示为<code>SVal</code>）。它还允许对符号值进行求值。</p>
<p>但是，要构建内存区域，应该使用<code>MemRegionManager</code>对象。有时，能够构造子区域是很有用的（例如，具有已知声明的结构区域的字段区域，以便稍后获得字段值）。</p>
<p>你几乎永远不应该构建一个<code>SymExpr</code>。要构造符号的少数情况包括创建某种<code>eval::Call</code>中创建某种<code>SymbolConjured</code>符号，以及在checker使用此机制时构造符号元数据(SymbolMetadata)。然而，大多数时候，您会从环境或区域存储收到所有必要的符号，甚至很少关心它们的种类。</p>
<p>在任何情况下，您都应该使用<code>SValBuilder</code>的方法，而不是直接访问<code>SymbolManager</code>对象，来构造所有类型的<code>SymExpr</code>。如果请求的符号是整型的，这些方法将返回包含该符号的<code>nonloc::SymbolVal</code>；如果请求的是指针类型，则返回包含包装该符号的<code>SymbolRegionVal</code>。在这两种情况下，都可以调用生成的<code>SVal</code>的<code>getAsSymbol()</code>方法来获取<code>SymExpr</code>本身。</p>
<h4 id="5-2-分析器的内存模型"><a href="#5-2-分析器的内存模型" class="headerlink" title="5.2  分析器的内存模型"></a>5.2  分析器的内存模型</h4><p><code>MemRegion</code>是一个内存段，当它存储在指针类型的SVal中时，它表示内存段的第一个字节的地址；但是，你仍然应该将MemRegion对象想象为承载了关于整个内存段的信息。</p>
<p>SVal类的getAsRegion()方法适用于以下SVal类型：</p>
<ul>
<li><code>loc::MemRegionVal</code> : 一个指针值，被描述为给定区域的第一个字节的地址</li>
<li><code>nonloc::LocAsInteger</code>: 一个类似的指针值，只存储在整数中。这种SVal表示指向整数强制转换的指针的结果。</li>
</ul>
<p>一些内存区域是其他区域的子区域。子区域是段内的子段。子区域继承自SubRegion类。每个子区域都有一个长度（“范围”），可以通过SubRegion的getExtent()获得该长度分区域方法。范围可以是具体的，也可以是符号化的。 </p>
<p>其它的内存区域，我们称之为”memory spaces”，并不属于其它的区域。</p>
<p>每个子区域恰有一个通过getSuperRegion()方法获得的直接超区域。以存储空间作为其直接超级区域的存储区域称为基区域(base region)。如果一个区域既不是内存空间也不是基区，那么在其超级区域链的末端正好有一个基区。有一个单独的类家族用于表示基本区域：通过只查看区域的类，可以确定它是内存空间内的基本区域，还是位于另一个基本区域内。 </p>
<p>可以使用getMemorySpace()方法获取该区域所属的内存空间，并使用getBaseRegion()获取任何子区域的基本区域。</p>
<p>基本区域（内存空间的直接子区域）可以是类型化的，也可以是非类型化的。类型化区域是保存已知类型值的区域。非类型化区域是具有未知类型值的区域，尽管您可能大致知道存储在那里的内容或其来源。</p>
<p>例如，考虑以下代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> x , y ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line"><span class="type">int</span> u , v ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="type">int</span> t ;</span><br><span class="line">B * b ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">( C c )</span> </span>&#123;</span><br><span class="line">c.b[<span class="number">5</span>].y ; <span class="comment">// &lt;-- that</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，下图大致描述了第20行上描述字段y的区域系统。 </p>
<p><img src="C:\Users\ticp\Documents\notes\image-20220518152913878.png" alt="image-20220518152913878"></p>
<p>如果你把这个区域dump()出来，你可能会看到：</p>
<p><code>base &#123; element &#123; SymRegion &#123; reg_$0 &lt;c - &gt;b &gt;&#125; ,5 S32b , struct B &#125; , A &#125; - &gt; y</code></p>
<p>用文字表述，它的意思是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FieldRegion for declaration of member variable y,</span><br><span class="line">	inside CXXBaseRegion for declaration of class A,</span><br><span class="line">		inside ElementRegion for element number 5 of type B,</span><br><span class="line">			inside SymbolicRegion for the pointer symbol of SymbolRegionValue kind,which represents the initial value of:</span><br><span class="line">FieldRegion for declaration of member variable b,</span><br><span class="line">	VarRegion for declaration of a local variable c.</span><br></pre></td></tr></table></figure>

<p>在读完本节后，你应该可以理解这张图的大部分内容（除了SymbolRegionValue，我们在5.5节会提到） </p>
<h5 id="5-2-1-内存空间"><a href="#5-2-1-内存空间" class="headerlink" title="5.2.1 内存空间"></a>5.2.1 内存空间</h5><p>内存空间继承自MemSpaceRegion类。大多数内存空间都是“单元集”，实际上它们很少： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-GlobalSpaceRegion-四个不同内存空间的基类：</span><br><span class="line">	-NonStaticGlobalSpaceRegion-所有非静态全局变量的单个内存空间，分为三个：</span><br><span class="line">		-GlobalImmutableSpaceRegion，由无法修改的全局变量组成</span><br><span class="line">		-GlobalSystemSpaceRegion，其中包括最有可能只由系统调用修改的变量，如errno</span><br><span class="line">		-GlobalInternalSpaceRegion，由其他全局变量组成</span><br><span class="line">	-StaticGlobalSpaceRegion-所有静态全局变量的内存空间</span><br><span class="line">-HeapPasceRegion-保存在堆上分配的所有区域</span><br><span class="line">-StackSpaceRegion-两个不同内存空间的基类：</span><br><span class="line">	-StackArgumentsSpaceRegion-函数调用参数的内存空间</span><br><span class="line">	-StackLocalSpaceRegion-局部变量的内存空间。</span><br><span class="line">	（请注意，与其他内存空间不同，可能有多个StackSpaceRegion实例-每个StackFrameContext对应一个实例。）</span><br><span class="line">-UnknownSpaceRegion—当分析器不知道区域实际存储在哪里时。 </span><br></pre></td></tr></table></figure>

<p>内存空间很重要，因为如果区域位于不同的内存空间中，即使这些区域的所有其他特征都相同，它们也会被认为是不同的。例如，函数参数变量在不同调用中的区域是不同的，因为即使变量声明是相同的，它们的内存空间也是由不同的堆栈帧上下文定义的。</p>
<h5 id="5-2-2-无类型基本区域"><a href="#5-2-2-无类型基本区域" class="headerlink" title="5.2.2 无类型基本区域"></a>5.2.2 无类型基本区域</h5><p>有三种类型的无类型区域：</p>
<ul>
<li><p>AllocaRegion<br>通过调用标准C库的alloca()函数在堆栈上分配的区域。此区域是非类型化的，因为此函数分配原始数据。<br>AllocareRegion始终位于StackLocalsSpaceRegion中。</p>
</li>
<li><p>SymbolicRegion<br>指针指向的区域，其值是一个符号表达式。这个区域是非类型化的，因为指针可以在C中自由转换，并且不能确保它指向的数据类型与指针类型匹配。SymbolicRegion类值得特别注意，因为指针符号（即使其类型是指针类型）在技术上是非LOC的。因此，SymbolicRegion类的目的是表达和传递Loc部分——一个在创建指针值之后创建的区域，而不是反过来。</p>
<p>如果一个子区域以SymbolicRegion作为其基本区域，则该区域被称为具有符号基础，并且该符号区域被称为该区域的符号基础。MemRegion的getSymbolicBase()方法返回指向符号基区的指针，如果基区不是符号的，则返回空指针。这个方法当您需要确定一个复杂的子区域是否实际与某个特定的指针符号相关时，将非常有用。</p>
<p>SymbolicRegion通常位于UnknownSpaceRegion中，因为指针的性质通常是未知的。然而，有时已知指针指向heap（例如，如果它是由默认操作符new返回的），那么该区域将位于HeapSpaceRegion中。堆符号区域是使用MemRegionManager的getSymbolCheapRegion()方法创建的。</p>
</li>
</ul>
<h5 id="5-2-3-有类型基本区域与有类型值"><a href="#5-2-3-有类型基本区域与有类型值" class="headerlink" title="5.2.3 有类型基本区域与有类型值"></a>5.2.3 有类型基本区域与有类型值</h5><p>类型化区域是共同具有称为TypedValueRegion的祖先类的区域，尽管并非其所有继承者都是基区域；实际上，基本区域的子区域也是类型化的。类型化区域的种类更多：</p>
<ul>
<li><p>VarRegion</p>
<p>VarRegion是变量的区域。对于每个AST全局或静态变量声明，都会定义一个VarRegion。对于堆栈变量，区域可以在不同的函数调用中有所不同，只需作为不同StackSpaceRegion内存空间的子区域即可。还要注意的是，类的成员变量根本不是基区，也从来没有用VarRegion表示。</p>
<p>根据变量声明的性质，VarRegion可能位于各种内存空间中。 </p>
</li>
<li><p>CXXThisRegion</p>
<p>CXXThisRegion是在C++方法调用期间存储隐式this指针的区域。这个类型化区域始终位于堆栈上，每个堆栈帧上下文（即每个StackArgumentsSpaceRegion空间）最多有一个CXXThisRegion，就像VarRegion的函数参数一样。</p>
<p>请注意，CXXThisRegion不是对象本身，而是一个存放指针的堆栈区域。对象本身就是存储在该区域中的符号值。对于顶级调用，对象区域将被描述为顶级堆栈帧的CXXThisRegion的SymbolRegionValue的SymbolRegion区域；特别是，它将是非类型化的，即使CXXThisRegion本身始终是类型化的。对于过程间分析期间的嵌套函数调用，可以键入当前对象区域（例如，当嵌套调用的堆栈帧的CXXThisRegion包含指向已知变量的VarRegion的指针时）。 </p>
</li>
<li><p>CXXTempObjectRegion<br>CXXTempObjectRegion表示C++临时对象的内存区域。当C++的语义需要创建辅助的不可见对象时，例如，在不使用new操作符直接调用构造函数来创建对象时，就会出现这种情况。此区域保存导致它出现的AST表达式的内存。</p>
<p>CXXTempObjectRegion可能位于StackLocalsSpaceRegion中，有时也可能位于GlobalInternalSpaceRegionKind中（当使用MemRegionManager的getCXXStaticTempObjectRegion()方法创建它时）。</p>
</li>
<li><p>CompoundLiteralRegion</p>
<p>CompoundLiteralRegion表示初始值设定项列表（“复合文字”）对象的内存区域。 </p>
</li>
<li><p>StringRegion</p>
<p>字符串文字的区域</p>
</li>
</ul>
<h5 id="5-2-4-无类型值的类型化基区域"><a href="#5-2-4-无类型值的类型化基区域" class="headerlink" title="5.2.4 无类型值的类型化基区域"></a>5.2.4 无类型值的类型化基区域</h5><p>有一些特殊类型的区域，继承自TypedRegion，但不是TypedValueRegion。这些区域具有定义良好的“位置”（指针）类型，但是它们存储的值的类型没有定义为位置类型的指针对象类型：</p>
<ul>
<li>BlockDataRegion<br>表示块内存储数据的基本区域（Apple Inc.对C和C++的非标准扩展）。这些区域负责处理块的代码和数据，并实现使用闭包的方法。</li>
<li>CodeTextRegion<br>表示程序代码的内存区域，而不是数据。有两个子类：<ul>
<li>FunctionTextRegion，函数代码，一般用于表示分析器中的函数指针值</li>
<li>BlockTextRegion，用于表示块代码。</li>
</ul>
</li>
</ul>
<h5 id="5-2-5-基区域的子区域"><a href="#5-2-5-基区域的子区域" class="headerlink" title="5.2.5 基区域的子区域"></a>5.2.5 基区域的子区域</h5><p>基本区域的子区域始终是类型化的，即使基本区域是非类型化的。</p>
<ul>
<li>CXXBaseObjectRegion是基类对象在派生类对象区域内的区域。该区域由AST中的基类声明定义</li>
<li>ElementRegion是实心一维数组中数组元素的区域。元素的索引是数组索引类型的任意非loc符号值，它可以是具体的整数，也可以是符号。该区域还携带类型信息；具有相同索引但不同类型的相同超区域的元素区域被视为不同的。<br>ElementRegion还用于表示非类型化区域的类型转换。例如，转换为类型<code>T*</code>的符号指针的值表示为该指针上符号区域的值类型T的元素区域。如果指针被进一步转换为另一种类型<code>S*</code>，则此ElementRegion可以替换为值类型S的另一个ElementRegion。</li>
<li>FieldRegion是结构、类或联合内的字段区域。与VarRegion类似，该区域也基于AST变量声明。</li>
</ul>
<p>请注意，ElementRegion并不表示指针解引用（相反，SymbolicRegion表示指针解引用），并且下标指针和数组的处理方式完全不同。例如，考虑一个函数foo：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>*p, <span class="type">int</span> a[<span class="number">5</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ticp\Documents\notes\image-20220520155707281.png" alt="image-20220520155707281"></p>
<p>那么a[5]将是参数变量a的VarRegion的ElementRegion，它位于StackArgumentsSpaceRegion中的某个位置：<br><code>element&#123;a,5 S32b,int&#125;</code></p>
<p>然而，p[5]是未知父区域中SymbolicRegion的ElementRegion，为参数变量p的符号指针值而构造：<br><code>element&#123;SymRegion&#123;reg_$0&lt;p&gt;&#125;,5 S32b, int&#125;</code></p>
<h4 id="5-3-具体值"><a href="#5-3-具体值" class="headerlink" title="5.3 具体值"></a>5.3 具体值</h4><p>具体值是编译时已知的值。如果一个整数变量的值已知为42，则存在一个表示它的具体值，并且没有两个不同的符号值可能由于某些意外同时表示它；一个就够了。 </p>
<h5 id="5-3-1-数字值"><a href="#5-3-1-数字值" class="headerlink" title="5.3.1 数字值"></a>5.3.1 数字值</h5><p>最原始的具体值就是表示编译时已知值的整数。在内部，nonloc::ConcreteInt在内部持有一个llvm::APSInt；您可以通过getValue()来获取它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nonloc::ConcreteInt CI = Val.<span class="built_in">castAs</span>&lt;nonloc::ConcreteInt&gt;();</span><br><span class="line"><span class="type">uint64_t</span> Int = CI.<span class="built_in">getValue</span>().<span class="built_in">getLimitedValue</span>();</span><br></pre></td></tr></table></figure>

<p>nonloc::ConcreteInt类的不同实例具有不同的数值、类型大小和符号性。然而，对于三者的每个组合，只有一个nonloc::ConcreteInt表示它；您无法区分从不同来源获得的两个32位有符号零。</p>
<p>loc::ConcreteInt是表示已知指针值的具体整数。它的内部类似于nonloc::ConcreteInt。通常loc::ConcreteInt的实例是指针宽度的无符号整数。在编译时不太可能知道内存地址，因此在loc::ConcreteInt中最常见的值是0，表示空指针。 </p>
<h5 id="5-3-2-复合值"><a href="#5-3-2-复合值" class="headerlink" title="5.3.2 复合值"></a>5.3.2 复合值</h5><p>具体复合值的最简单示例是nonloc::CompoundVal，它表示初始值设定项列表或字符串的具体r值。在内部，它包含存储在文本中的SVal的llvm::ImmutableList。</p>
<p>然而，分析器中使用了另一个复合值，在分析中出现频率高很多，它就是nonloc::LazyCompoundVal。该值是一个r-value，表示分析过程中给定时刻任何结构“作为一个整体”的快照。该值远不可被称为“具体值”，因为其中的许多字段都是未知的或符号化的。nonloc::LazyCompoundVal存储两项内容：</p>
<ul>
<li>对正在快照的TypedValueRegion的引用（是的，它总是有类型的）</li>
<li>从创建它的ProgramState获取的整个Store对象的副本。</li>
</ul>
<p>从本质上讲，nonloc::LazyCompoundVal是为了分析器的性能优化。因为Store是不可变的，所以创建nonloc::LazyCompoundVal是一个低成本的操作。请注意，Store包含程序状态下的所有区域绑定，而不仅仅与区域相关。之后，如有必要，可以对该值进行解压缩；例如，将其分配给另一个变量时。 </p>
<h4 id="5-4-特殊值"><a href="#5-4-特殊值" class="headerlink" title="5.4 特殊值"></a>5.4 特殊值</h4><p>本小节描述了为特殊目的保留的两个单例值。</p>
<h5 id="5-4-1-未定义值"><a href="#5-4-1-未定义值" class="headerlink" title="5.4.1 未定义值"></a>5.4.1 未定义值</h5><p>每当分析器内核需要强调某个东西（表达式或区域）的值根据语言标准<strong>未定义</strong>时，就会生成一个UndefinedVal。UndefinedVal就一种：您无法区分从不同来源获得的两个UndefinedVal。</p>
<p>大多数情况下，每当出现未定义的行为时，都应该有一个checker来警告发生了未定义的行为。有多个官方检查模块在核心中抛出此类警告。</p>
<p>出现UndefinedVal的常见情况是试图获取未初始化变量的值。</p>
<p>这是在ProgramState的方法assume(…)中唯一被禁止的值。</p>
<h5 id="5-4-2-未知值"><a href="#5-4-2-未知值" class="headerlink" title="5.4.2 未知值"></a>5.4.2 未知值</h5><p>每当符号执行引擎无法用符号表示某个值时，它就会创建另一个称为UnknownVal的特殊值。与UndefinedVal一样，UnknownVal是一个单例值；你不能区分从不同来源获得的两个未知值。但是，您可以区分UnknownVal和UndefinedVal。</p>
<p><code>UnknownVal</code>可能随时随地出现。当符号表达式超过其复杂性限制时，通常会出现这种情况。它在任何地方的出现，无论多么关键，都不会立即表明程序中有错误，但很可能表明分析器内核出现故障：未知值缺少明确的符号，这会破坏符号执行的目的。大多数情况下，分析器会为这些值“变戏法”地搞一个特殊符号，但有时它希望确保您完全不对该值进行任何假设，因而创建一个未知值。当您在checker回调中遇到未知值时，最好避免抛出警告。</p>
<h4 id="5-5-符号表达式"><a href="#5-5-符号表达式" class="headerlink" title="5.5 符号表达式"></a>5.5 符号表达式</h4><p>符号表达式，也被称为符号，毫无疑问是符号执行背后整个理念的本质。</p>
<p>符号是永恒的：符号值在分析过程中不能“改变”。创建符号后，它在整个分析过程中表示相同的值。然而，当分析在程序中进一步进行时，可能会收集有关该值的新信息，并以对该符号施加范围约束的形式存储在ProgramState中。</p>
<p>例如，在if语句的true分支上，表示条件值的符号将为非零。在false分支上，它将被认为等于零，本质上变成了一个具体的值；事实上，getSVal(…)将在内部用具体的整数0替换这样的符号。 </p>
<p>然而，符号值的分类并不那么重要。大多数情况下，关于符号，您需要了解的最重要的一点是，由相同符号表示的值总是相等的，而不同的符号可能相同也可能不同。事实上，即使所有的符号都是SymbolConjured类型，大多数分析都能很好地工作。以下是我们因拥有不同符号类的层次结构而获得的一些好处：</p>
<ul>
<li>RangeConstraintManager使用符号二进制表达式类来显著简化约束条件，例如，<code>(x+3)&gt;5</code>很容易转换为x&gt;2，如果表示（x+3）的符号不记得x或3的任何信息，这将很难实现。</li>
<li>通过对符号中存储的区域的引用，污染自动从污染区域传播到表示其值的数据符号。</li>
<li>在任何时候，我们都可以轻松地以高层次的方式追踪符号的起源。如果我们想找出复现分析器发现的bug所需的条件，我们可以通过查看程序状态内的符号来执行此操作。</li>
<li>它也对调试很有用，有时（很少）checker本身的内部逻辑依赖于符号类型。然而，你应该知道你在做什么；这个技术常被误用用于「快速而肮脏且错误」的启发式。本小节应该让您大致了解什么是符号，什么不是符号。</li>
</ul>
<p>符号值总是有一种类型，即整数或指针。</p>
<p>SVal类的getAsSymbol()方法适用于以下SVal类型：</p>
<ul>
<li>nonloc::SymbolVal，作为“符号”本身的值。</li>
<li>loc::MemRegionVal，如果其中的区域是一个符号区域（“符号指针”，因为nonloc::SymbolVal总是nonloc，此方法将指针表示为loc值）。在这种情况下，该方法将返回为其构造区域的符号。如果getAsSymbol()的可选布尔参数设置为true，则此方法也适用于具有符号基的任意区域。</li>
<li>nonloc::LocAsInteger，从基础loc::MemRegionVal（如果有）中提取符号指针。</li>
</ul>
<h5 id="5-5-1-操作符号"><a href="#5-5-1-操作符号" class="headerlink" title="5.5.1 操作符号"></a>5.5.1 操作符号</h5><p>有三个符号表示其他符号上的二进制运算符：</p>
<ul>
<li>SymIntExpr表示另一个符号和具体整数之间的二进制运算结果，例如x+5；</li>
<li>IntSymExpr表示一个具体整数和另一个符号之间的二进制运算的结果，例如3&gt;x；</li>
<li>SymSymExpr表示一个具体整数和另一个符号之间的二进制运算的结果（如x∗ y）。 请注意，SymSymExpr符号很少由分析器创建，因为它们对于RangeConstraintManager几乎没有用处，因为RangeConstraintManager无法处理复杂的约束。通常，当其中一个操作数被污染时，会出现SymSymExpr，以保存污染信息。 </li>
<li>还有SymbolCast，它表示从另一个符号转换为特定类型的结果。</li>
</ul>
<h5 id="5-5-2-戏法符号"><a href="#5-5-2-戏法符号" class="headerlink" title="5.5.2 戏法符号"></a>5.5.2 戏法符号</h5><p>SymbolConjured是在其他所有操作都失败时的一种回退：分析器根本无法从表达式中理解任何含义，因此它至少生成一些符号以保持路径敏感性。SymbolConjured的常见示例包括由于其主体的源代码不可用或其他原因而未由分析器建模的函数的返回值；它也用于失效的目的。 </p>
<h5 id="5-5-3-区域值符号"><a href="#5-5-3-区域值符号" class="headerlink" title="5.5.3 区域值符号"></a>5.5.3 区域值符号</h5><p>我们已经多次提到，最原始的“敏感”原子（“数据”）符号可能是SymbolRegionValue。它表示分析开始时存储在内存区域中的值。此符号包含对区域的引用。考虑以下示例： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = a;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析开始时（第2行之前），b的值是UndefinedVal，而a的值是SymbolRegionValue类的符号，表示参数变量a的区域值。</p>
<p>在第2行之后，b的值更改为代表a值的SymbolRegionValue</p>
<p>在第3行，a的值更改为nonloc::ConcretInt，值为1。但是，b仍然为变量a的区域保留SymbolRegionValue类型的符号，它仍然表示a的原始值，而不是新的具体值1。另一个与SymbolRegionValue密切相关的原子符号是SymbolDerived。它表示另一个符号被写进了一个直接或间接的超级区域之后，一个区域的值。SymbolDerived包含对父符号和父区域的引用。这个符号主要是一种技术黑客行为。通常SymbolDerived在吴无效化之后出现：某一类型的整个结构被一个戏法符号打破，然后其字段的值通过戏法符号的SymbolDerived和字段区域的符号来表示。在任何情况下，SymbolDerived与SymbolRegionValue类似，只是指分析过程中某个事件之后的值，而不是分析开始时的值。 </p>
<h5 id="5-5-4-范围符号"><a href="#5-5-4-范围符号" class="headerlink" title="5.5.4 范围符号"></a>5.5.4 范围符号</h5><p>正如我们在第5.2小节中提到的，每个内存区域都是一段字节。我们通常对第一个字节的地址感兴趣，但有时我们可能会试图找出区域的长度（“范围”），这可能是已知的（对于普通可变区域）或未知的（通常是符号区域，实际上可能是长度未知的数组）。当范围未知时，它用一个称为SymbolExtent的特殊符号表示。此符号包含区域的引用。 </p>
<p>当然，如果需要获取某个区域的范围，则不应手动创建新的SymbolExtent；您可以依赖SubRegion的getExtent(…)方法。</p>
<h5 id="5-5-5-元数据符号"><a href="#5-5-5-元数据符号" class="headerlink" title="5.5.5 元数据符号"></a>5.5.5 元数据符号</h5><p>元数据符号是具有特定于checker含义的符号，与内存区域相关联。checker可以创建这样的符号，并管理它们的生存期和垃圾收集（通过check::LiveSymbols回调）。analyzer核心从不自行创建SymbolMetadata；只有checker才能创建此类符号。</p>
<p>可以使用SValBuilder创建新的符号元数据。下面是官方alpha的一个示例代码。它创建表示字符串长度的元数据符号： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SValBuilder &amp; SVB = C.<span class="built_in">getSValBuilder</span>();</span><br><span class="line">QualType SizeTy = SVB.<span class="built_in">getContext</span> ().<span class="built_in">getSizeType</span> ();</span><br><span class="line">SVal StrLength = SVB.<span class="built_in">getMetadataSymbolVal</span>(CStringChecker::<span class="built_in">getTag</span>(),MR,Ex,SizeTy,C.<span class="built_in">blockCount</span> ());</span><br></pre></td></tr></table></figure>

<p>SymbolMetadata由以下成分组成：</p>
<ul>
<li>符号标记，唯一标识一种元数据符号的void*。在本例中，正在使用检查器对象的静态getTag()方法返回的检查器本身的唯一标识符。</li>
<li>元数据绑定到的父区域；在我们的例子中，它是定义长度的字符串区域。</li>
<li>符号出现的AST表达式。</li>
<li>符号的预期类型。正如SValBuilder方法所期望的那样，如果此类型是Loc，则生成的SVal将是Loc::MemRegionVal类型，带有一个包装符号的符号区域。</li>
<li>-块计数：分析期间访问CFG块的次数。这允许在分析过程中多次通过同一表达式时，对同一区域的同一表达式上创建的符号进行区分。</li>
</ul>
<h5 id="5-5-6-污染值"><a href="#5-5-6-污染值" class="headerlink" title="5.5.6 污染值"></a>5.5.6 污染值</h5><p>如上所述，任何符号，且只有符号，都可能带有污染。然而，为了方便起见，其他值被称为从它们所依赖的符号继承污染信息。下面是通过符号值层次结构进行污染传播的完整案例列表：</p>
<ul>
<li>在以下情况下称内存区域受到污染：<ul>
<li>使用污染指针符号构造的符号区域；</li>
<li>当使用受污染的索引值构造ElementRegion时；</li>
<li>任何类型的区域都会从其超级区域继承污染。</li>
</ul>
</li>
<li>在以下情况下，符号可以继承污染，而不考虑其自身的污染信息：<ul>
<li>SymbolRegionValue可以从其父区域继承污染；</li>
<li>SymbolDerived可以从其父符号继承污染，但不能从其父区域继承污染；</li>
<li>所有运算符号都从其操作数继承污染。</li>
</ul>
</li>
<li>当用getAsSymbol()提取的符号或用getAsRegion()提取的区域被污染时，SVal被称为被污染。</li>
</ul>
<p>这些启发式方法大大简化了checker中的污染操作。</p>
<h4 id="5-7-理解debug转储"><a href="#5-7-理解debug转储" class="headerlink" title="5.7 理解debug转储"></a>5.7 理解debug转储</h4><p>所有的三种符号值类都允许使用一个方便的dump()方法进行调试。对于大多数值类型，此方法会生成一个可识别的模式，它可以告诉您有关值的许多有用信息。考虑一个例子： </p>
<p><code>reg_$2 &lt; element &#123; SymRegion &#123; derived_$1 &#123; conj_$0 &#123; int &#125; ,a - &gt; ptr &#125;&#125; ,0 S32b , int &#125; &gt;</code></p>
<p>此SVal是一个符号，即SymbolRegionValue，由reg_$N&lt;…&gt;包装器表示。数字N是分配给SymbolManager对象内每个符号的内部符号计数器。 </p>
<p>此符号表示ElementRegion中有符号整数的原始值，索引0位于对应于符号指针的特定SymbolicRegion内。分析器无法确定该指针是指向数组还是指向单个整数；但是，可以肯定的是，为了获得原始值，该指针会被取消引用。</p>
<p>指针本身是一个SymbolDerived，它是从int类型的SymbolConjured派生出来的，用于某个结构变量a的字段ptr的FieldRegion。SymbolDerived本身是SymbolRegion的基础，它必然是一个指针值。然而，SymbolConjured的类型不是指针；它很可能是结构a失效的结果。</p>
<p>因此，该值可以用文字描述为“失效期间最初存储在a.ptr字段中出现的指针后面的整数的值”。考虑另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; base &#123; base &#123; base &#123;d , C &#125; , B &#125; , A &#125; [ as <span class="number">64</span> bit integer ]</span><br></pre></td></tr></table></figure>

<p>此值是一个nonloc::LocAsInteger，表示转换为64位整数的位置的具体值。该位置是一个loc::MemRegionVal（因此前缀“&amp;”）保存某个区域。区域本身是对象d的类a的C++基对象的区域（它可能属于类d，您可以通过转储变量d的声明来检查这一点）。但是，由于D不是a的直接后代，因此可以在区域层次结构中看到整个类继承路径。</p>
<h4 id="5-8-延伸阅读"><a href="#5-8-延伸阅读" class="headerlink" title="5.8 延伸阅读"></a>5.8 延伸阅读</h4><p>Z.Xu，T.Kremenek和J.Zhang在一篇文章中详细描述了Clang静态分析器的存储模型：</p>
<p>Z. Xu, T . Kremenek, and J. Zhang. A memory model for static analysis of C programs. In: ISoLA’10 Proceedings of the 4th<br>international conference on Leveraging applications of formal methods, verification, and validation. pp. 535–548 (2010)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/11/CSA%20Guide%20CN%20CH4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/CSA%20Guide%20CN%20CH4/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-11 19:00:00" itemprop="dateCreated datePublished" datetime="2022-05-11T19:00:00+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-22 22:00:39" itemprop="dateModified" datetime="2022-05-22T22:00:39+08:00">2022-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH4-路径敏感的分析"><a href="#CH4-路径敏感的分析" class="headerlink" title="CH4 路径敏感的分析"></a>CH4 路径敏感的分析</h3><p>CSA的设计是基于名为“符号执行”的静态分析方法。此方法基于程序的抽象解释，并假定将符号值赋给程序变量，再将程序的所有可能状态划分为使程序通过相同路径的状态类。  </p>
<p>程序状态（Program State）的类通常由符号值上施加的范围约束来定义。 不过，它们在其它方面可能会有所不同，甚至可能包含一些特定于checker的差异。</p>
<p>分析器会实现一种保存特定内存区段（memory region）中抽象和具体值的内存模型，并且在分析的时候使用它们。</p>
<p>路径敏感的引擎支持过程间分析，这意味着任何时候当分析器遇到一个函数调用，它都会试图为这个函数调用建模。并且进一步分析其中的子函数。</p>
<h4 id="4-1-从程序状态中获取信息"><a href="#4-1-从程序状态中获取信息" class="headerlink" title="4.1 从程序状态中获取信息"></a>4.1 从程序状态中获取信息</h4><p><code>Programstate</code>是路径敏感分析中的基础数据结构之一。它持有待分析瞬间程序状态的完整信息。从中你可以获得保存在内存区域中的符号值信息和定义在当前上下文环境中的表达式信息。</p>
<p><code>Program state</code>是不可变（immutable）的。一旦一个<code>Programstate</code>被创建了。你就不能修改它。你只能再新建一个和原始的不同的<code>Programstate</code>对象。除此之外，你永远不能直接访问<code>Programstate</code>。或者手动管理它们的生命周期，它们都被包装在基于引用技术的智能指针<code>ProgramStateRef</code>中。</p>
<p>在绝大多数路径敏感的checker回调函数中，你拥有一个可以使用的<code>CheckerContext</code>。一个它持有的关键信息是当前的程序状态，你可以简单的获得它，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkEndFunction</span><span class="params">(CheckerContext &amp;C)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Program State</code>保存了以下关于程序的特性：</p>
<ul>
<li>环境 Environment ：活跃表达式的符号值</li>
<li>区域存储 Region Store ： 内存区域的符号值</li>
<li>范围约束 Range Constraints：符号值可以取值的范围</li>
<li>污染 Taint：从不安全的来源获得的符号值注册信息;</li>
<li>通用数据映射 Generic Data Map：特定checker的信息</li>
</ul>
<h5 id="4-1-1-获取表达式的值"><a href="#4-1-1-获取表达式的值" class="headerlink" title="4.1.1 获取表达式的值"></a>4.1.1 获取表达式的值</h5><p>分析器记录了所有它当前所需要的表达式的符号值。任何时候，当一个表达式离开了当前的上下文环境，它会触发垃圾回收机制，并不再可用。这种从表达式到符号值的映射关系称之为environment。如果一个表达式在当前的environment中是可获取的，你就可以拿到它的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Expr *E = <span class="comment">/* some expr */</span></span><br><span class="line"><span class="type">const</span> LocationContext *LC = C.<span class="built_in">getLocationContext</span>();</span><br><span class="line">SVal Val = State -&gt; <span class="built_in">getSVal</span>(E,LC);</span><br></pre></td></tr></table></figure>

<p>如果表达式E在当前的环境中是可获取的，则Val就会是它的符号值，否则将会返回一个<code>unknownval</code>。environment不会试图计算任何一个AST表达式的值，它只会返回一个已经存在的值。你可以确定找到的东西包括：在分析整表达式之前，其子表达式的值以及任何一个刚刚被分析过的表达式的值。这些信息对于实际需要来说通常是够用的。</p>
<h5 id="4-1-2-关于内存区域的简要介绍"><a href="#4-1-2-关于内存区域的简要介绍" class="headerlink" title="4.1.2 关于内存区域的简要介绍"></a>4.1.2 关于内存区域的简要介绍</h5><p>内存区域（memory region）是符号化的左值。其出现的场景，例如分析指针的符号值时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Expr *E = <span class="comment">/* pointer expression*/</span>;</span><br><span class="line"><span class="type">const</span> MemRegion *Reg = State-&gt;<span class="built_in">getSVal</span>(E,LC).<span class="built_in">getAsRegion</span>();</span><br></pre></td></tr></table></figure>

<p>内存区域也可以直接借助变量的声明来获得。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> VarDecl *D = <span class="comment">/* var decl */</span>;</span><br><span class="line"><span class="type">const</span> MemRegion *Reg = State-&gt;<span class="built_in">getSVal</span>(D,LC).<span class="built_in">getAsRegion</span>();</span><br></pre></td></tr></table></figure>

<p>那上面两个例子中如果值并不是一个内存区域则函数调用会返回一个空指针。</p>
<p>内存区域可以包含符号值; 获取这些值可能需要将内存区域作为指针来解引用。 解内存区域引用的机制称为区域存储（Region Store）。 每个<code>ProgramState</code>包含存储的一个实例，它携带已知的符号值到内存区域的对应关系。</p>
<p>从Program State获取region binding的方法很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SVal Val = State-&gt;<span class="built_in">getSVal</span>(Reg);</span><br></pre></td></tr></table></figure>

<p>与Environment不同，Region Store会在没有binding的时候尝试生成一个合理的binding。 在这种情况下，它将构造并返回一个表示该区域未知值的符号。 这意味着你总是可以依赖<code>getSVal (const MemRegion *)</code>来产生一个合理的符号值。  </p>
<h5 id="4-1-3-迭代访问Region-Store-Binding"><a href="#4-1-3-迭代访问Region-Store-Binding" class="headerlink" title="4.1.3 迭代访问Region Store Binding"></a>4.1.3 迭代访问Region Store Binding</h5><p>使用region store的最常用操作是获取其中特定memory region的binding。不过有的时候也许你希望列出所有的显式binding。在<code>StoreManager</code>类（它持有所有region store实例）中，有一个名叫<code>BindingHandler</code>的机制可以迭代访问特定program state中的所有binding。</p>
<p>为了使用binding handler，你需要继承它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Callback</span> : <span class="keyword">public</span> StoreManager::BindingHandler&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">HandleBinding</span><span class="params">(StoreManager &amp;SM, Store St,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> MemRegion *Region, SVal Val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何时候需要停止迭代的话，就把这个布尔值返回false。一旦已经定义了这个回调函数，你就可以开始迭代：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CallBack CB;</span><br><span class="line">StoreManager &amp;SM = C.<span class="built_in">getStoreManager</span>();</span><br><span class="line">SM.<span class="built_in">iterBindings</span>(State-&gt;<span class="built_in">getStore</span>(),CB);</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-对符号值的假设"><a href="#4-1-4-对符号值的假设" class="headerlink" title="4.1.4 对符号值的假设"></a>4.1.4 对符号值的假设</h5><p>对于一个程序状态而言，你可以从中获得任意一个符号值或者做出一个关于它的布尔条件假设。也就是说它代表一个true或者一个false。为了检验假设，这个值本身要么已被定义的，要么是unknown。未定义的值是不能被检验的。一旦你确定这个值不是未定义的，你就可以使用program state的assume方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SVal Val = <span class="comment">/* a certain symbolic value */</span>;</span><br><span class="line">Option&lt;DefinedOrUnknownSVal&gt; DVal = Val.<span class="built_in">getAs</span>&lt;DefinedOrUnknownSVal&gt;();</span><br><span class="line"><span class="keyword">if</span>(!DVal) </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(State-&gt;<span class="built_in">assume</span>(*Dval, <span class="literal">true</span>))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(State-&gt;<span class="built_in">assume</span>(*Dval, <span class="literal">false</span>))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果这个值并不确定是true还是false，两个statement都可以触发。</p>
<h5 id="4-1-5-符号值上的操作"><a href="#4-1-5-符号值上的操作" class="headerlink" title="4.1.5 符号值上的操作"></a>4.1.5 符号值上的操作</h5><p>假定你有一个符号值a和一个符号之b，你希望假定a比b大。为了做这个操作，你需要表示a大于b，作为一个新的符号值（或者说是一个布尔类型）c。你可以使用<code>SValBuilder</code>来创建一个新的符号值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SVal A,B;</span><br><span class="line">ASTContext &amp;Ctx= C.<span class="built_in">getASTContext</span>();</span><br><span class="line">SValBuilder &amp;SVB = C.<span class="built_in">getSValBuilder</span>();</span><br><span class="line">SVal C = SVB.<span class="built_in">evalBinOp</span>(State,BO_GT, A,B,&amp;Ctx.BoolTy);</span><br></pre></td></tr></table></figure>

<h5 id="4-1-6-使用污染分析"><a href="#4-1-6-使用污染分析" class="headerlink" title="4.1.6 使用污染分析"></a>4.1.6 使用污染分析</h5><p>如果一个符号值的获取，借助了一些不可信的来源，例如阅读标准输入或者文件描述符，乃至于一些环境变量，那么这个符号值会称之为<strong>被污染</strong>。污染分析是一种有效的寻找安全缺陷的方法。例如基于敏感函数中受污染值的调用而检测SQL注入。</p>
<p>在一个特定的程序状态中，你永远可以确定一个特定的符号值是否被污染：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">SVal Val = <span class="comment">/* a certain synbolic value*/</span>;</span><br><span class="line"><span class="keyword">if</span>(State-&gt;<span class="built_in">isTainted</span>(Val))&#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数污染信息来自于默认内建于CSA的checker，最典型的比如<code>alpha.security.taint.TaintPropagation</code>。如果你希望自己定义污染来源或者说扩展污染分析可以看4.2.4。</p>
<h4 id="4-2-改变和分割程序状态"><a href="#4-2-改变和分割程序状态" class="headerlink" title="4.2 改变和分割程序状态"></a>4.2 改变和分割程序状态</h4><p>路径敏感的checker不止观察分析器内核对程序的符号执行，也会主动参与对程序行为的建模。切口会主动把它的特性加到程序状态中修改region store binding。或者range constraints乃至于切分程序状态。也就是说一个特定的行为如果可能有多个不同的结果，那么就会让程序采取不同的执行路径。</p>
<p>记得注意的是切分程序状态必须十分小心，因为每一次切分都会使得学习期内和对于当前剩余爆炸图子树的总工作量加倍。如果切分的次数非常多，分析的速度会被极大程度地降低。</p>
<h5 id="4-2-1-向爆炸图增加边"><a href="#4-2-1-向爆炸图增加边" class="headerlink" title="4.2.1 向爆炸图增加边"></a>4.2.1 向爆炸图增加边</h5><p>正如在2.3节所说的那样，路径敏感的分析器引擎使用图的形式来表示分析的过程，称之为爆炸图。在图中的节点。我们称为爆炸节点。被定义为一个程序点（一个控制流图中的单一元素被以一个程序点的形式表示。或者如果（有必要的话）不止一个）和一个程序状态的有序对。每一个statement会让我们从一个现有的节点到达另一个新创建的节点，或者（如果它此时的行为有很多种，那么有可能）到很多个节点。</p>
<p>实际上爆炸图并不一定是一棵树，它有可能有环。任何时候当到达一个相同的程序点时具有相同程序状态，一个环就产生了。于是对于这条分支的分析会自动停止：因为这很可能发生了一次死循环，或者时一个checker中的bug。</p>
<p>不可以修改任何已经存在的爆炸图节点（nodes），程序点（points）或者程序状态（states），它们是不可修改的，你所有可以做的事情是：制造一个新的程序状态。或者一个新的附属程序点，也许两者都有；然后使用<code>CheckerContext</code>对象来增加一条转换边（transition）。</p>
<p>修改一个程序状态的某方面属性的代码长这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProgarmStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">State = <span class="built_in">modifyState</span>(State); <span class="comment">// do stuff</span></span><br><span class="line">C.<span class="built_in">addTransition</span>(State);</span><br></pre></td></tr></table></figure>

<p>如果你希望增加多条转向不同的节点的转换边，你可能会想做这样的事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProgarmStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">ProgarmStateRef State1 = <span class="built_in">modifyState</span>(State);</span><br><span class="line">ProgarmStateRef State2 = <span class="built_in">modifyState</span>(State);</span><br><span class="line">C.<span class="built_in">addTransition</span>(State1);</span><br><span class="line">C.<span class="built_in">addTransition</span>(State2);</span><br></pre></td></tr></table></figure>

<p>你可能并不希望是并行的多条，而是一系列顺序的转换，那么你可以使用这个接受一个前驱节点作为参数的重载方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProgarmStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">State = <span class="built_in">modifyState</span>(State); <span class="comment">// do stuff</span></span><br><span class="line">ExplodeNode *N = C.<span class="built_in">addTransition</span>(State);</span><br><span class="line">State = <span class="built_in">modifyState</span>(State, N);</span><br><span class="line">C.<span class="built_in">addTransition</span>(State,N);</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-切分范围约束假设的状态"><a href="#4-2-2-切分范围约束假设的状态" class="headerlink" title="4.2.2 切分范围约束假设的状态"></a>4.2.2 切分范围约束假设的状态</h5><p>在4.1.4节所描述的assume方法。会返回一个带有添加的假设的新的程序状态；或者如果假设无法被满足，那么是一个空的程序状态。我们可以做的并不只是把它转换成布尔值来看条件是否可以被满足，也可以添加转换边来转到新创建的状态。</p>
<p>举例来说，如果你的checker需要告诉分析器一个特定的函数不能返回零，你可以假定它的返回值的符号值是非零的，然后添加一个函数调用后的假定状态的转换边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SVal Val = Call.<span class="built_in">getReturnValue</span> ();</span><br><span class="line">Optional &lt;DefinedOrUnknownSVal &gt; DVal = Val.getAs &lt;<span class="built_in">DefinedOrUnknownSVal</span> (); </span><br><span class="line"><span class="keyword">if</span> (!DVal) <span class="keyword">return</span>;</span><br><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span> ();</span><br><span class="line">State = State -&gt;<span class="built_in">assume</span> (*DVal , <span class="literal">true</span>);</span><br><span class="line">C.<span class="built_in">addTransition</span>(State);</span><br></pre></td></tr></table></figure>

<p>在对应的转换之后，分析器就知道在这之后所有剩下的执行路径中，这个值是非零的。</p>
<p>有的时候你可能会增加并行的转换，然后转向一条true和一条false，这样做的好处是什么呢？实际上符号执行的整个核心想法就是状态切分。你所做的事情和分析器在遇到一个if语句的时候所做的完全一致：其考虑一个单一的分支而缺乏有效信息，不如考虑两条分支，在每一条上都有一些事情是已知的。这意味着如果一个checker需要知道，比如说这个值是不是零，来汇报缺陷。这种情况下，checker就会知道其中一条分支上发生了缺陷。如果没有状态切分的话，checker是保持沉默的，不能判断在程序路径上一定会存在一些缺陷。</p>
<h5 id="4-2-3-创造region-store-binding"><a href="#4-2-3-创造region-store-binding" class="headerlink" title="4.2.3 创造region store binding"></a>4.2.3 创造region store binding</h5><p>有的时候你可能希望修改程序状态来把一个特定的符号值绑定到一个位置上。一个典型的使用情景是手动模拟一个分析器不能建模的函数。举例来说，一个特定函数的代源代码是不可达的；你可以把你对于它的理解刻画到checker中，并试图模拟这种行为。然后如果你知道这个函数会把一个特定的符号值写到一个特定的位置。你可以告诉checker来这样建模它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span> ();</span><br><span class="line">SVal Loc = <span class="comment">/* Obtain a location */</span>;</span><br><span class="line">SVal Val = <span class="comment">/* Obtain a value */</span>;</span><br><span class="line">State = State -&gt;<span class="built_in">bindLoc</span>(Loc , Val);</span><br><span class="line">C.<span class="built_in">addTransition</span>(State);	</span><br></pre></td></tr></table></figure>

<h5 id="4-2-4-扩展污染分析"><a href="#4-2-4-扩展污染分析" class="headerlink" title="4.2.4 扩展污染分析"></a>4.2.4 扩展污染分析</h5><p>为了让污染分析有效，分析器需要知道哪些事件会污染符号值，以及污染会借助什么样的事件扩散到其它的符号值上。这两个事情都可以借助checker来扩展。</p>
<p>对于扩展污染来源而言，订阅任何匹配所需事件的checker回调函数，并使用<code>ProgramState</code>的<code>addTaint(...)</code>方法。这个方法有三个重载，允许我们把污染加到不同类的符号值上。  </p>
<p>把污染加到当前环境中的表达式上的方法是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocationContext *LC = C.<span class="built_in">getLocationContext</span>();</span><br><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span> ();</span><br><span class="line"><span class="type">const</span> Expr *E = <span class="comment">/* Obtain an expression value of which is untrusted */</span>; ProgramStateRef NewState = State -&gt;<span class="built_in">addTaint</span>(E, LC); </span><br><span class="line"><span class="keyword">if</span> (NewState != State) <span class="comment">// avoid loops in the exploded graph</span></span><br><span class="line">    C.<span class="built_in">addTransition</span>(NewState);</span><br></pre></td></tr></table></figure>

<p>对于数字值而言：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span> ();</span><br><span class="line">SVal V = <span class="comment">/* Obtain a numeric symbol from an untrusted source */</span>; </span><br><span class="line"><span class="keyword">if</span> (SymbolRef Sym = V.<span class="built_in">getAsSymbol</span> ()) &#123;</span><br><span class="line">    ProgramStateRef NewState = State -&gt;<span class="built_in">addTaint</span>(Sym);</span><br><span class="line">    <span class="keyword">if</span> (NewState != State) </span><br><span class="line">        C.<span class="built_in">addTransition</span>(NewState );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于指向不信任数据的指针而言：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProgramStateRef State = C.<span class="built_in">getState</span> ();</span><br><span class="line">SVal V = <span class="comment">/* Obtain a symbolic location from an untrusted source */</span>; ProgramStateRef NewState = State -&gt;<span class="built_in">addTaint</span>(V.<span class="built_in">getAsRegion</span>()); </span><br><span class="line"><span class="keyword">if</span> (NewState != State)</span><br><span class="line">	C.<span class="built_in">addTransition</span>(NewState);</span><br></pre></td></tr></table></figure>

<p>要注意的是，你不能对具体值做污染标记。比如说一个代表着32位的有符号整数”0“的符号值不可以被标记为被污染的。事实上，分析器甚至不会区分不同的”0“的实例。</p>
<p>默认规则是：如果一个特定的符号值被标记为被污染，那么基于它的算数运算的结果也会被标记为被污染，如果一个区域被标记为污染那么所有从中产生的值也被标记为污染。不过，如果一个不相关的值被写入了一块污染区域，这个值不会被考虑为被污染。除此之外，具有被污染的符号值数组下标的数组成员元素也会默认被标记为污染。</p>
<p>不过，很多复杂的事情可能会发生。举例来说，它有可能被传入了一个返回另一符号值的函数。或者也许这个函数并不能被内核所建模，那么你就需要手动扩展污染的扩散规则：捕捉到你认为导致污染扩散的事件，检测是否被污染，然后把污染加到因为你认为已被扩散到的值上。</p>
<p>正如在4.1.6节中所说，大多数通常意义上的污染源和扩散规则已经在内置的checker中定义。其中也包含了很多关于污染的例子。对于你自己的checker来说，添加自己的污染源和扩散规则也许是有必要的。</p>
<p>想知道哪些特定种类的符号值可以携带污染以及为什么它们可以，请看5.6。</p>
<h5 id="4-2-5-使用程序状态中的特性"><a href="#4-2-5-使用程序状态中的特性" class="headerlink" title="4.2.5 使用程序状态中的特性"></a>4.2.5 使用程序状态中的特性</h5><p>Checker可以按它们自己想要的往程序状态中增加特征（trait)，这些特征被保存在一个特定的结构中，称之为generic data map(GDM)。</p>
<p>使用自定义的程序特征的最主要情景是检查由一系列（而不是单一）的事件触发的错误。一个非常典型的例子是多次释放：当同一个对象被多次回收的时候是错误的，但任何一次单一的回收行为本身并不是一次错误。为了创造一个checker来处理对应的情况。通常的做法是创建一个从符号值标识符到它们的状态（unknown&#x2F;live&#x2F;deleted）的映射关系，使用GDM来保存这个映射关系。于是检查的特征就可以称之为：正在回收一个已被标记为已回收的对象。</p>
<p>一个新手checker撰写者所常犯的错误是把这个映射关系保存在checker自己的类域中。这也正是为什么所有checker的回调函数被使用const修饰的原因：一般来说很少有情况，你需要往checker的state中存储任何东西。绝大多数情况下，checker是与state无关的。在整个分析过程中，这些引擎从一个分支跳到另一个分支是非常正常的一件事情。但是在一个分支上某对象被标记为已回收，并不意味着在其它程序执行路径的分支上也是这样标记的。这正说明了checker中的成员变量，并不是一个合适的存放关于程序状态信息的地方，因为它对于所有的分支都是一致的。只有程序状态本身适合存放。</p>
<p>和程序状态本身一样，GDM也是不可修改的。这也正说明了，想要在GDM里面保存一些数据，你需要使用LLVM的不可变容器：<code>llvm::ImmutableList, llvm::ImmutableSet, llvm::ImmutableMap </code>。否则性能会下降的非常严重，因为程序状态会被复制过多次。</p>
<p>想要在程序状态中插入一个特征，需要在你checker代码的全局范围内（而非某命名空间中，也不能是多个TU都可以接触到的地方）使用四个预定义宏中的一个：</p>
<ul>
<li><code>REGISTER_TRAIT_WITH_PROGRAMSTATE(TraitName, Type)</code><br>这个宏可以让程序状态携带一个类型为Type的特征。你可以使用<code>State-&gt;get&lt;TraitName&gt;()</code>来获取这个特征，并得到它当前状态中的值；或者借助<code>State-&gt;set&lt;TraitName&gt;(NewValue)</code>来获取一个新的带特征的特征状态。此外，<code>TraitNameTy</code>和<code>Type</code>是同义的。</li>
<li><code>REGISTER_LIST_WITH_PROGRAMSTATE(ListName , ElementType)</code><br>特征类型为LLVM的不可变列表，其中的元素类型是<code>ElementType</code>。你可以通过<code>State-&gt;add&lt;ListName&gt;(NewItem)</code>来扩展，或者使用<code>State-&gt;scan&lt;ListName&gt;(NewItem)</code>来检查。</li>
<li><code>REGISTER_SET_WITH_PROGRAMSTATE(SetName , ElementType)</code><br>特征类型为LLVM的不可变集合，其中的元素类型是<code>ElementType</code>。集合支持<code>add&lt;&gt;()</code>和<code>contains&lt;&gt;()</code>，也支持<code>remove&lt;&gt;()</code></li>
<li><code>REGISTER_MAP_WITH_PROGRAMSTATE(MapName , KeyType , ValueType)</code><br>顾名思义。它支持<code>remove&lt;&gt;()</code>，但是不支持<code>add&lt;&gt;()</code>。不过，<code>get&lt;&gt;()</code>和<code>set&lt;&gt;()</code>是很方便的。</li>
</ul>
<p>如果<code>Type, ElementType, KeyType, ValueType</code>中的任何一个不是一个整型或指针类型，那么这些类型在运行时需要满足一些条件。具体来说，为了可以作为不可变容器的成员元素，它们需要提供一个<code>Profile()</code>方法，来让LLVM可以把它们当作折叠集(folding set)中的节点。</p>
<p>例如，你不能直接把<code>std::string</code>或者<code>llvm::StringRef</code>放进去，你需要做一些包装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringWrapper</span> &#123; </span><br><span class="line">    <span class="type">const</span> std:: string Str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringWrapper</span>(<span class="type">const</span> std:: string &amp;S) : <span class="built_in">Str</span>(S) &#123;&#125;</span><br><span class="line">    <span class="type">const</span> std:: <span class="function">string &amp;<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Str; &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Profile</span><span class="params">(llvm:: FoldingSetNodeID &amp;ID)</span> <span class="type">const</span> </span>&#123; ID.<span class="built_in">AddString</span>(Str);&#125; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> ==( <span class="type">const</span> StringWrapper &amp;RHS) <span class="type">const</span> &#123; <span class="keyword">return</span> Str == RHS.Str; &#125; </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;( <span class="type">const</span> StringWrapper &amp;RHS) <span class="type">const</span> &#123; <span class="keyword">return</span> Str &lt; RHS.Str; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后这样使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REGISTER_SET_WITH_PROGRAMSTATE</span>(MyStringSet, StringWrapper)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyChecker::checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call, CheckerContext &amp;C)</span> </span>&#123;</span><br><span class="line">  ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = Call.<span class="built_in">getCalleeIdentifier</span>()) &#123;</span><br><span class="line">    std::string Str = II-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    State = State-&gt;<span class="built_in">add</span>&lt;MyStringSet&gt;(<span class="built_in">StringWrapper</span>(Str));</span><br><span class="line">    C.<span class="built_in">addTransition</span>(State);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (State-&gt;<span class="built_in">contains</span>&lt;MyStringSet&gt;(<span class="built_in">StringWrapper</span>(<span class="string">&quot;main&quot;</span>))) &#123; </span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是<code>Sval</code>类型它自己的profile方法。如果你希望保存一个复杂结构，可以这样实现它的profile方法，填充其中的所有域：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MyStructure :: <span class="built_in">Profile</span>(llvm:: FoldingSetNodeID &amp;ID) <span class="type">const</span> &#123; </span><br><span class="line">    ID.<span class="built_in">AddPointer</span>(Sym); </span><br><span class="line">    Val.<span class="built_in">Profile</span>(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-路径敏感checker的回调函数"><a href="#4-3-路径敏感checker的回调函数" class="headerlink" title="4.3 路径敏感checker的回调函数"></a>4.3 路径敏感checker的回调函数</h4><p>路径敏感的checker通过繁多的checker回调函数持续与分析器内核交互。不同的回调函数由不同的事件触发。这一节主要介绍各个回调函数。</p>
<h4 id="4-3-1-check-PreStmt-lt-T-gt"><a href="#4-3-1-check-PreStmt-lt-T-gt" class="headerlink" title="4.3.1 check::PreStmt&lt;T&gt;"></a>4.3.1 <code>check::PreStmt&lt;T&gt;</code></h4><p>原型为：<code>void checkPreStmt(const T *S, CheckerContext &amp;C) const;</code></p>
<p>这是一个注册于AST上类型为T的statement的Check他会在每一次遇到一个类型为T的statement的时候触发。在这个回调函数中，你可以获得T的子statement的值。</p>
<p>这个回调函数不会在控制流语句上生效（例如if）。如果需要检查这样的语句，请订阅<code>check::BranchCondition</code>。</p>
<p>使用这个回调函数的例子，可以参照<code>core.DivideZero</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DivZeroChecker::checkPreStmt</span><span class="params">(<span class="type">const</span> BinaryOperator *B, CheckerContext &amp;C)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    BinaryOperator::Opcode Op = B-&gt;<span class="built_in">getOpcode</span>();</span><br><span class="line">    SVal Denom = C.<span class="built_in">getState</span>()-&gt;<span class="built_in">getSVal</span>(B-&gt;<span class="built_in">getRHS</span>(),C.<span class="built_in">getLocationContext</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个切克使用了binary operator作为类的特化参数，订阅了每一个被建模的二元运算符。然后就在第三行，他检查了究竟是哪一个操作运算符被建模了；因为他只需要关注除法。然后在第五行他获得了被除数的符号值。</p>
<h5 id="4-3-2-check-PostStmt-lt-T-gt"><a href="#4-3-2-check-PostStmt-lt-T-gt" class="headerlink" title="4.3.2 check::PostStmt&lt;T&gt;"></a>4.3.2 <code>check::PostStmt&lt;T&gt;</code></h5><p><code>void checkPostStmt(const T *S, CheckerContext &amp;C) const;</code></p>
<p>这个回调函数模板和前一个很像，唯一的区别是它会在这个statement被建模之后才触发。如果S是一个表达式，那么它可以获得S本身的符号值；但是S中所有子表达式的符号值已经被删除了。</p>
<p>一个使用这个checker的好的例子可以看<code>unix.Malloc</code> checker。他会寻找关于内存的问题，比如内存泄露或者多次释放。他订阅了<code>CXXNewExpr</code>来追踪使用new分配内存的指针的符号值。</p>
<h5 id="4-3-3-check-PreCall"><a href="#4-3-3-check-PreCall" class="headerlink" title="4.3.3 check::PreCall"></a>4.3.3 <code>check::PreCall</code></h5><p><code>void checkPreCall(const CallEvent &amp;Call, CheckerContext &amp;C) const;</code></p>
<p>这个方便的回调函数只是<code>check::PreStmt&lt;CallExpr&gt;</code>的一个更方便的版本。 它会在调用执行之前的同一时刻触发，不管它是否会被”过程间分析引擎”处理。 区别在于<code>check::PreCall</code>中你拥有<code>CallEvent</code>的结构，从这个结构中你可以很容易地获得被调用对象的符号值，所有的参数，以及c++隐含的this参数。  </p>
<p>在这个回调中，通常会尝试找出被调用的函数。 最简单的方法是获取被调用标识符的名称，并将其与给定的字符串进行比较。 然而，字符串比较是一个复杂的操作。更快捷的方法是存储我们想要的函数的标识符，然后比较标识符指针。  </p>
<p>我们已经看到在<code>alpha.core.MainCallChecker</code>中使用<code>check::PreCall</code>。 你也可以在默认的CSA发行版的<code>alpha.unix.SimpleStreamChecker</code>中找到<code>check::PreCall</code>的使用示例。  </p>
<p>首先，让我们看看它是如何获取标识符指针以实现更快的函数查找的:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleStreamChecker::initIdentifierInfo</span><span class="params">(ASTContext &amp;ACtx)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (IIfclose)</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">IIfclose = &amp;Ctx.Idents.<span class="built_in">get</span>(<span class="string">&quot;fclose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ASTContext.Idents</code>是当前TU的标识符表。你可以在通过名字查到标识符，然后存储起来供自己快速查询。</p>
<p>这个回调函数使用了CallEvent来迅速判断被调用的函数是不是我们在查找的那个，并在此基础上做了检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleStreamChecker::checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call,CheckerContext &amp;C)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">initIdentifierInfo</span>(C.<span class="built_in">getASTContext</span>());</span><br><span class="line">  <span class="keyword">if</span> (!Call.<span class="built_in">isGlobalCFunction</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (Call.<span class="built_in">getCalleeIdentifier</span>() != IIfclose)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (Call.<span class="built_in">getNumArgs</span>() != <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  SymbolRef FileDesc = Call.<span class="built_in">getArgSVal</span>(<span class="number">0</span>).<span class="built_in">getAsSymbol</span>(); <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-4-check-PostCall"><a href="#4-3-4-check-PostCall" class="headerlink" title="4.3.4 check::PostCall"></a>4.3.4 <code>check::PostCall</code></h5><p><code>void checkPostCall(const CallEvent &amp;Call, CheckerContext &amp;C) const;</code></p>
<p>类似于<code>check::PreCall</code>，这是<code>check::PostStmt&lt;CallExpr&gt;</code>的快捷回调，其中<code>CallEvent</code>结构是可用的。 它在任何函数调用之后立即触发。 你可以通过<code>call.getReturnValue()</code>获得计算出来的返回值。  </p>
<p>使用技巧与<code>check::PreCall</code>非常相似，这些回调通常是成对使用的。 例如<code>alpha.unix. SimpleStreamChecker</code>使用<code>check::PreCall</code> 来处理<code>fclose()</code>调用(需要访问参数)和<code>check::PostCall</code>来处理<code>fopen()</code>(需要访问返回值)。 同样<code>unix.Malloc</code>checker在<code>check::PostCall</code>回调中捕获<code>malloc()</code>，并使用<code>check::PreCall</code>来跟踪之后的<code>free()</code> 。</p>
<h5 id="4-3-5-check-Location"><a href="#4-3-5-check-Location" class="headerlink" title="4.3.5 check::Location"></a>4.3.5 <code>check::Location</code></h5><p><code>void checkLocation(SVal L, bool IsLoad , const Stmt* S, CheckerContext &amp;C) const;</code></p>
<p>每当被分析的程序寻址到一个特定的内存位置时，这个回调就会被触发，无论是为了从它读取一个值，还是为了向它写入一个值。 符号值L是要检查的左值(一般来说是一个内存区域)，只要对L的访问是只读的，<code>IsLoad</code>就被置位。 值L是描述语句S的。如果你想获得被访问的语句本身，需要查看它的父语句，可能通过使用<code>ParentMap</code>。此外，<code>CheckerContext</code>和往常一样是可以用的。</p>
<p>当对验证位置而不是值感兴趣时，即当访问位置是感兴趣的“那个”事件时，使用这个回调。<code>core.NullDereference</code>给出了一个很好的使用示例，通过订阅<code>check::Location</code>来检测未定义的或空指针位置值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DereferenceChecker::checkLocation</span><span class="params">(SVal L, <span class="type">bool</span> IsLoad, <span class="type">const</span> Stmt *S,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       CheckerContext &amp;C)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check for dereference of an undefined value.</span></span><br><span class="line">  <span class="keyword">if</span> (L.<span class="built_in">isUndef</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ExplodedNode *N = C.<span class="built_in">generateSink</span>()) &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  DefinedOrUnknownSVal Location = L.<span class="built_in">castAs</span>&lt;DefinedOrUnknownSVal&gt;(); <span class="comment">// Check for null dereferences.</span></span><br><span class="line">  <span class="keyword">if</span> (!Location.<span class="built_in">getAs</span>&lt;Loc&gt;())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">  ProgramStateRef NotNullState, NullState;</span><br><span class="line">  llvm::<span class="built_in">tie</span>(NotNullState, NullState) = State-&gt;<span class="built_in">assume</span>(Location);</span><br><span class="line">  <span class="keyword">if</span> (NullState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!NotNullState) &#123; <span class="comment">/* ... */</span></span><br><span class="line">    &#125;                    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，checker实现了各种各样的测试，以探索位置值是什么样的，并据此产生不同类型的警告。你可以看到它如何首先检测未定义的位置值(捕获<code>UndefinedVal</code>)，然后尝试假设该位置在当前程序状态下为空或非空，并基于此做出决策。 checker左了程序状态分割，以便在空和非空位置之间进行区分(如果这两种变量都是可能的)。  </p>
<h5 id="4-3-6-check-Bind"><a href="#4-3-6-check-Bind" class="headerlink" title="4.3.6 check::Bind"></a>4.3.6 <code>check::Bind</code></h5><p><code>void checkBind(SVal L, SVal V, const Stmt *S, CheckerContext &amp;C) const;</code></p>
<p>这个回调有点类似于<code>check::Location</code>。 每当一个值绑定到一个位置时，它就会被调用，位置和值分别作为符号值L和V可用。 与check::Location不同，check::Bind不会在Location被加载时被调用；而是只有当由于程序的写操作而出现区域绑定（region binding）时，才会调用它。  </p>
<p>关于<code>check::Bind</code>的一个实际例子，你可以看<code>alpha.core.BoolAssignment</code>，它检查是否将0或1以外的值赋给布尔类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoolAssignmentChecker::checkBind</span><span class="params">(SVal L, SVal V, <span class="type">const</span> Stmt *S,CheckerContext &amp;C)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We are only interested in stores into Booleans.</span></span><br><span class="line">    <span class="type">const</span> TypedValueRegion *TR =</span><br><span class="line">        <span class="built_in">dyn_cast_or_null</span>&lt;TypedValueRegion&gt;(L.<span class="built_in">getAsRegion</span>());</span><br><span class="line">    <span class="keyword">if</span> (!TR)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    QualType valTy = TR-&gt;<span class="built_in">getValueType</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isBooleanType</span>(valTy))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Optional&lt;DefinedSVal&gt; DV = V.<span class="built_in">getAs</span>&lt;DefinedSVal&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!DV)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">    SValBuilder &amp;SVB = C.<span class="built_in">getSValBuilder</span>();</span><br><span class="line">    DefinedSVal ZeroVal = SVB.<span class="built_in">makeIntVal</span>(<span class="number">0</span>, valTy);</span><br><span class="line">    SVal GreaterThanOrEqualToZeroVal = SVB.<span class="built_in">evalBinOp</span>(</span><br><span class="line">        State, BO_GE, *DV, ZeroVal, SVB.<span class="built_in">getConditionType</span>()); <span class="comment">/* ... */</span></span><br><span class="line">    DefinedSVal OneVal = SVB.<span class="built_in">makeIntVal</span>(<span class="number">1</span>, valTy);</span><br><span class="line">    SVal LessThanEqToOneVal =</span><br><span class="line">        SVB.<span class="built_in">evalBinOp</span>(State, BO_LE, *DV, OneVal, SVB.<span class="built_in">getConditionType</span>());</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该checker首先检查位置来查看该位置是否为布尔类型。 不是每个内存区域都有一个类型; 例如，任何空指针都指向一个特定的内存区域，但是checker不能负担起对存储在该区域的值的类型进行假设。 包含显式已知类型值的Region是<code>MemRegion</code>的子类，称为<code>TypedValueRegion</code>。 这里，除非L所指向的区域确实是布尔类型，否则checker就返回了（关于各种存储区域类型的详细讨论，请参见第5.2节）。然后checker继续计算值V是否等于0或1。 为此，它使用<code>SValBuilder</code>创建符号比较值，假设它们为真或假，并根据这些假设做出决策。  </p>
<h5 id="4-3-7-check-EndAnalysis"><a href="#4-3-7-check-EndAnalysis" class="headerlink" title="4.3.7 check::EndAnalysis"></a>4.3.7 <code>check::EndAnalysis</code></h5><p><code>void checkEndAnalysis(ExplodedGraph &amp;G, BugReporter &amp;BR , ExprEngine &amp;Eng) const;</code></p>
<p>每当路径敏感分析器完成对某个函数代码体的分析时，此回调将触发一次。  </p>
<p>当函数体被完全分析完时，分析被重置(并调用<code>check::EndAnalysis</code>回调)。 因此，在分析一个翻译单元时，这个回调函数可能会被多次调用(换句话说，在Checker对象生存期期间，或者说，在clang运行期间，可能会被多次调用)。  </p>
<p>此回调只对每个函数代码体触发一次，而不是对函数的每个分支触发一次。 这就是为什么<code>CheckerContext</code>在这个回调中不可用，并且你不能获得当前的<code>ProgramState</code>。 相反，你拥有可用的整个<code>ExplodedGraph</code>。 你还可以访问<code>BugReporter</code>来抛出错误报告，以及<code>ExprEngine</code>对象，它是分析器引擎的唯一实例。  </p>
<p>当你想在整个分析过程中收集统计数据时，<code>check::EndAnalysis</code>是有用的。 使用<code>check::EndAnalysis</code>的一个极端例子是检查死代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnreachableCodeChecker::checkEndAnalysis</span><span class="params">(ExplodedGraph &amp;G, BugReporter &amp;BR,ExprEngine &amp;Eng)</span> <span class="type">const</span> </span>&#123; <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">if</span> (Eng.<span class="built_in">hasWorkRemaining</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">for</span> (ExplodedGraph ::node_iterator I = G.<span class="built_in">nodes_begin</span>(), E = G.<span class="built_in">nodes_end</span>();</span><br><span class="line">       I != E; ++I) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个路径敏感的checker通过理解引擎在函数的符号执行期间执行了哪些路径来查找死代码。  </p>
<p>有时函数会因为太复杂而被丢弃。在这种情况下，<code>hasWorkRemaining()</code>将返回true，并且checker将避免跳转到结论。 然后checker继续迭代，通过ExplodedGraph来查找到达了哪些CFG块。  </p>
<h5 id="4-3-8-check-EndFunction"><a href="#4-3-8-check-EndFunction" class="headerlink" title="4.3.8 check::EndFunction"></a>4.3.8 <code>check::EndFunction</code></h5><p>每次分析器离开函数体时都会触发此回调。 与<code>check::EndAnalysis</code>不同，它触发函数的每一个可能的返回，以及程序执行的每一个分支。 此外，当过程间分析被启用时，这个回调不仅会在分析结束时触发，而且在内联函数调用的分析结束时也会触发。  </p>
<p>考虑一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (c) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>check::EndFunction</code>在顶部分析<code>foo()</code>时触发两次，在<code>bar()</code>调用<code>foo()</code>时触发四次，在<code>bar()</code>分析时触发八次，总共14次。相比之下，<code>check::EndAnalysis</code>会被<code>foo()</code>调用一次，<code>bar()</code>调用一次；<code>bar()</code>中调用<code>foo()</code>时它不会被调用。</p>
<p>如果你想在分析结束时找出函数上下文的剩余内容，那么你一般会希望订阅<code>check::EndFunction</code>。 一个例子是<code>StackAddressEscape</code>checker。 该checker遍历所有区域存储绑定，以便在函数结束时找到存储在全局变量中的局部变量的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StackAddrEscapeChecker::checkEndFunction</span><span class="params">(CheckerContext &amp;C)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CallBack</span> : <span class="keyword">public</span> StoreManager ::BindingsHandler &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    CheckerContext &amp;C;</span><br><span class="line">    <span class="type">const</span> StackFrameContext *CurSFC;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SmallVector&lt;std::pair&lt;<span class="type">const</span> MemRegion *, <span class="type">const</span> MemRegion *&gt;, <span class="number">10</span>&gt; V;</span><br><span class="line">    <span class="built_in">CallBack</span>(CheckerContext &amp;CC)</span><br><span class="line">        : <span class="built_in">C</span>(CC), <span class="built_in">CurSFC</span>(CC.<span class="built_in">getLocationContext</span>()-&gt;<span class="built_in">getCurrentStackFrame</span>()) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">HandleBinding</span><span class="params">(StoreManager &amp;SMgr, Store Store, <span class="type">const</span> MemRegion *Region,</span></span></span><br><span class="line"><span class="params"><span class="function">                       SVal Val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">isa</span>&lt;GlobalsSpaceRegion&gt;(Region-&gt;<span class="built_in">getMemorySpace</span>()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="type">const</span> MemRegion *VR = Val.<span class="built_in">getAsRegion</span>();</span><br><span class="line">      <span class="keyword">if</span> (!VR)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* ... */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="type">const</span> StackSpaceRegion *SSR =</span><br><span class="line">              <span class="built_in">dyn_cast</span>&lt;StackSpaceRegion&gt;(VR-&gt;<span class="built_in">getMemorySpace</span>())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SSR-&gt;<span class="built_in">getStackFrame</span>() == CurSFC)</span><br><span class="line">          V.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(Region, VR));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">  <span class="function">CallBack <span class="title">CB</span><span class="params">(C)</span></span>;</span><br><span class="line">  C.<span class="built_in">getStoreManager</span>().<span class="built_in">iterBindings</span>(State-&gt;<span class="built_in">getStore</span>(), CB);</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意StackFrameContext结构的用法。 通过比较当前堆栈帧和堆栈区域的堆栈帧，checker可以判断堆栈内存区域是属于相同的还是不同的堆栈帧。 当使用<code>check::EndFunction</code>回调函数时，你几乎总是需要找到当前的<code>stackframecontext</code>。  </p>
<h5 id="4-3-9-check-BranchCondition"><a href="#4-3-9-check-BranchCondition" class="headerlink" title="4.3.9 check::BranchCondition"></a>4.3.9 <code>check::BranchCondition</code></h5><p><code>void checkBranchCondition(const Stmt *S, CheckerContext &amp;C) const;</code></p>
<p>在程序分析期间发生的每个控制流分支上都会触发这个回调。 不像<code>check::PreStmt</code>和<code>check::PostStmt</code>回调会触发每个CFG基本块中的每条语句，<code>check::BranchCondition</code>会触发每个CFG终止符。 这些终止符可以包括if语句、条件循环，甚至逻辑操作中的短路。  </p>
<p>如果想弄清楚程序使用什么来做出控制流决策，就订阅这个回调。例如，可以研究在环境中可用的条件的符号值的起源。  </p>
<p>官方的<code>core.uninitialized.Branch</code>依赖于这个回调来查找依赖于未定义值的分支条件:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> UndefBranchChecker :: <span class="built_in">checkBranchCondition</span>(<span class="type">const</span> Stmt *S, </span><br><span class="line">                                                CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    SVal Val = C.<span class="built_in">getState</span>()-&gt;<span class="built_in">getSVal</span>(S, C.<span class="built_in">getLocationContext</span> ()); </span><br><span class="line">    <span class="keyword">if</span> (Val.<span class="built_in">isUndef</span> ()) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-10-check-LiveSymbols"><a href="#4-3-10-check-LiveSymbols" class="headerlink" title="4.3.10 check::LiveSymbols"></a>4.3.10 <code>check::LiveSymbols</code></h5><p><code>void checkLiveSymbols(ProgramStateRef State , SymbolReaper &amp;SR) const;</code></p>
<p>此回调允许checker手动管理符号表达式范围约束的垃圾收集。 <code>SymbolReaper</code>对象负责符号的垃圾收集; 你还可以访问此回调中的当前程序状态。  </p>
<p>大多数时候，除非你真的知道自己在做什么，否则这个回调只对元数据符号有用。<code>SymbolMetadata</code>是一种特殊的符号表达式，由checker本身创建和管理，这个回调对于管理这样的符号的生命周期是必要的。例如，<code>alpha.unix.cstring.OutofBounds</code>依赖这个回调函数来标记表示字符串长度的元数据符号:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CStringChecker ::<span class="built_in">checkLiveSymbols</span>(ProgramStateRef State,</span><br><span class="line">                                       <span class="number">2</span> SymbolReaper &amp;SR) <span class="type">const</span> &#123;</span><br><span class="line">  CStringLengthTy Entries = State-&gt;<span class="built_in">get</span>&lt;CStringLength&gt;();</span><br><span class="line">  <span class="keyword">for</span> (CStringLengthTy ::iterator I = Entries.<span class="built_in">begin</span>(), E = Entries.<span class="built_in">end</span>();</span><br><span class="line">       I != E; ++I) &#123;</span><br><span class="line">    SVal Len = I.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="keyword">for</span> (SymExpr ::symbol_iterator SI = Len.<span class="built_in">symbol_begin</span>(),</span><br><span class="line">                                   SE = Len.<span class="built_in">symbol_end</span>();</span><br><span class="line">         SI != SE; ++SI)</span><br><span class="line">      SR.<span class="built_in">markInUse</span>(*SI);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当字符串相同时，表示字符串长度的符号就是活的: 即使持有字符串的内存区域是相同的,把结束符改成一个非空字符(或在前面插入一个空字符)将改变c风格的字符串。于是长度和代表旧的符号长度不再是必要的,可以为垃圾收集被释放。  </p>
<p>这并不意味着这个符号会立即被删除；例如，只要它仍然存储在区域存储中的另一个变量中，就不会删除它，即使checker释放了它。  </p>
<p>元数据符号将在5.5.5中详细讨论。</p>
<h5 id="4-3-11-check-DeadSymbols"><a href="#4-3-11-check-DeadSymbols" class="headerlink" title="4.3.11 check::DeadSymbols"></a>4.3.11 <code>check::DeadSymbols</code></h5><p><code>void checkDeadSymbols(SymbolReaper &amp;SymReaper , CheckerContext &amp;C) const;</code></p>
<p>这个回调函数在符号被垃圾回收，而<code>check::LiveSymbols</code>没有阻止这一点时，被调用。</p>
<p>在这个回调中，checker会收到通知，在进一步的分析过程中不会再次遇到这个符号，你可以停止在特定于checker的数据结构中跟踪它，典型的就是从程序状态中的GDM中删除符号信息。  </p>
<p>这也意味着由符号表示的值不再存储在被分析的程序中的任何地方，这个值将永远丢失。例如，如果这个符号是一个已分配但在分析过程中没有释放的内存地址，那么这个符号的死亡就是一个内存泄漏：一旦这个符号死亡，程序就没有办法释放它。  </p>
<p><code>alpha.unix.SimpleStream</code>使用<code>check::DeadSymbols</code>来清理GDM和查找文件描述符泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SimpleStreamChecker ::<span class="built_in">checkDeadSymbols</span>(SymbolReaper &amp;SymReaper,CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">    SymbolVector LeakedStreams;</span><br><span class="line">    StreamMapTy TrackedStreams = State-&gt;<span class="built_in">get</span>&lt;StreamMap&gt;();</span><br><span class="line">    <span class="keyword">for</span> (StreamMapTy ::iterator I = TrackedStreams.<span class="built_in">begin</span>(),</span><br><span class="line">         E = TrackedStreams.<span class="built_in">end</span>();</span><br><span class="line">         I != E; ++I) &#123;</span><br><span class="line">        SymbolRef Sym = I-&gt;first;</span><br><span class="line">        <span class="type">bool</span> IsSymDead = SymReaper.<span class="built_in">isDead</span>(Sym);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isLeaked</span>(Sym, I-&gt;second, IsSymDead, State))</span><br><span class="line">            LeakedStreams.<span class="built_in">push_back</span>(Sym);</span><br><span class="line">        <span class="keyword">if</span> (IsSymDead)</span><br><span class="line">            State = State-&gt;<span class="built_in">remove</span>&lt;StreamMap&gt;(Sym);</span><br><span class="line">    &#125;</span><br><span class="line">    ExplodedNode *N = C.<span class="built_in">addTransition</span>(State);</span><br><span class="line">    <span class="built_in">reportLeaks</span>(LeakedStreams, C, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-3-12-check-RegionChanges"><a href="#4-3-12-check-RegionChanges" class="headerlink" title="4.3.12 check::RegionChanges"></a>4.3.12 <code>check::RegionChanges</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wantsRegionChangeUpdate</span><span class="params">(ProgramStateRef State)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">ProgramStateRef <span class="title">checkRegionChanges</span><span class="params">(ProgramStateRef State, <span class="type">const</span> InvalidatedSymbols *Invalidated, ArrayRef &lt;<span class="type">const</span> MemRegion *&gt; ExplicitRegions, ArrayRef &lt;<span class="type">const</span> MemRegion *&gt; Regions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> CallEvent *Call)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>这对回调函数监视区域存储中的所有更改。与<code>check:: bind::Location</code>不同，这个回调在失效时也会被调用，提供相关信息，比如可选调用事件。  </p>
<p>如下表所示，与<code>check::Location</code>或<code>check::Bind</code>相比，<code>check::RegionChanges</code>调用的次数更多，从而确保对存储中的所有更改进行彻底监控。 此回调的调用代价也很高，因为将显示已更改符号和区域的完整列表。 这就是为什么应该定义一个辅助回调<code>wantsRegionChangeUpdate()</code>以优化调用<code>checkRegionChanges()</code>所需的工作。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>Location</th>
<th>Bind</th>
<th>RegionChanges</th>
</tr>
</thead>
<tbody><tr>
<td>从变量中读取</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>赋值运算符</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>初始化</td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>创建临时值</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>默认绑定</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>绑定被垃圾回收</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>无效化</td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>例如，在官方的<code>alpha.unix.cstring.OutOfBounds</code>checker中，每当checker在追踪一个至少一个Cstring的长度时，<code>RegionChangeUpdate()</code>返回true：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REGISTER_MAP_WITH_PROGRAMSTATE</span>(CStringLength, <span class="type">const</span> MemRegion *, SVal)</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="type">bool</span> CStringChecker ::<span class="built_in">wantsRegionChangeUpdate</span>(ProgramStateRef State) <span class="type">const</span> &#123;</span><br><span class="line">  CStringLengthTy Entries = State-&gt;<span class="built_in">get</span>&lt;CStringLength&gt;();</span><br><span class="line">  <span class="keyword">return</span> !Entries.<span class="built_in">isEmpty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，checker继续遍历Regions数组，以删除已更改区域及其子区域和超区域的字符串长度条目的入口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ProgramStateRef CStringChecker ::<span class="built_in">checkRegionChanges</span>(</span><br><span class="line">    ProgramStateRef State, <span class="type">const</span> InvalidatedSymbols *Invalidated,</span><br><span class="line">    ArrayRef&lt;<span class="type">const</span> MemRegion *&gt; ExplicitRegions,</span><br><span class="line">    ArrayRef&lt;<span class="type">const</span> MemRegion *&gt; Regions, <span class="type">const</span> CallEvent *Call) <span class="type">const</span> &#123;</span><br><span class="line">  llvm::SmallPtrSet&lt;<span class="type">const</span> MemRegion *, <span class="number">8</span>&gt; InvalidatedRegions;</span><br><span class="line">  llvm::SmallPtrSet&lt;<span class="type">const</span> MemRegion *, <span class="number">32</span>&gt; SuperRegions;</span><br><span class="line">  <span class="keyword">for</span> (ArrayRef&lt;<span class="type">const</span> MemRegion *&gt;::iterator I = Regions.<span class="built_in">begin</span>(),</span><br><span class="line">                                             E = Regions.<span class="built_in">end</span>();</span><br><span class="line">       I != E; ++I) &#123;</span><br><span class="line">    <span class="type">const</span> MemRegion *MR = *I;</span><br><span class="line">    InvalidatedRegions.<span class="built_in">insert</span>(MR);</span><br><span class="line">    SuperRegions.<span class="built_in">insert</span>(MR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">const</span> SubRegion *SR = <span class="built_in">dyn_cast</span>&lt;SubRegion&gt;(MR)) &#123;</span><br><span class="line">      MR = SR-&gt;<span class="built_in">getSuperRegion</span>();</span><br><span class="line">      SuperRegions.<span class="built_in">insert</span>(MR);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  CStringLengthTy::Factory &amp;F = State-&gt;<span class="built_in">get_context</span>&lt;CStringLength&gt;();</span><br><span class="line">  <span class="keyword">for</span> (CStringLengthTy ::iterator I = Entries.<span class="built_in">begin</span>(), E = Entries.<span class="built_in">end</span>();</span><br><span class="line">       I != E; ++I) &#123;</span><br><span class="line">    <span class="type">const</span> MemRegion *MR = I.<span class="built_in">getKey</span>();</span><br><span class="line">    <span class="keyword">if</span> (SuperRegions.<span class="built_in">count</span>(MR)) &#123;</span><br><span class="line">      Entries = F.<span class="built_in">remove</span>(Entries, MR);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> MemRegion *Super = MR;</span><br><span class="line">    <span class="keyword">while</span> (<span class="type">const</span> SubRegion *SR = <span class="built_in">dyn_cast</span>&lt;SubRegion&gt;(Super)) &#123;</span><br><span class="line">      Super = SR-&gt;<span class="built_in">getSuperRegion</span>();</span><br><span class="line">      <span class="keyword">if</span> (InvalidatedRegions.<span class="built_in">count</span>(Super)) &#123;</span><br><span class="line">        Entries = F.<span class="built_in">remove</span>(Entries, MR);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> State-&gt;<span class="built_in">set</span>&lt;CStringLength&gt;(Entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获得更好的性能，无效区域的超区域被存储在<code>llvm::SmallPtrSet</code>中，这对于子区域当然是有问题的。 还要注意checker是如何避免为每个区域删除创建多个中间程序状态，而是直接在不可变map上工作的。</p>
<h5 id="4-3-13-check-PointerEscape"><a href="#4-3-13-check-PointerEscape" class="headerlink" title="4.3.13 check::PointerEscape"></a>4.3.13 <code>check::PointerEscape</code></h5><p><code>ProgramStateRef c hec kP oi nte rE sc ape ( ProgramStateRef State , const In val id at edS ym bo ls &amp; Escaped , const CallEvent * Call , Point erEscape Kind Kind ) const ;</code></p>
<p>每当一个指针值被赋给一个全局变量，或者传递给一个分析程序不能建模的函数时，这个指针就被称为“escape”。这样的指针就不能再被可靠地跟踪了。当指针发生逃逸时，将调用<code>check::PointerEscape</code>，以便通知checker注意它们感兴趣的逃逸指针。</p>
<p>如果在无效化期间发生指针转义，则会提供有关调用事件的信息。</p>
<p>类似于<code>check::DeadSymbols</code>可用于检测资源泄漏，<code>check::PointerEscape</code>可用于消除此类检查中的误报:逃逸的指针可能在我们不知情的情况下被释放，或者指针以外的值可能被更改。在<code>alpha.unix.SimpleStreamChecker</code>，这个回调用于查找逃逸的文件描述符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProgramStateRef <span class="title">SimpleStreamChecker::checkPointerEscape</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ProgramStateRef State, <span class="type">const</span> InvalidatedSymbols &amp;Escaped,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CallEvent *Call, PointerEscapeKind Kind)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Kind == PSK_DirectEscapeOnCall &amp;&amp; <span class="built_in">guaranteedNotToCloseFile</span>(*Call)) &#123;</span><br><span class="line">    <span class="keyword">return</span> State;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (InvalidatedSymbols ::const_iterator I = Escaped.<span class="built_in">begin</span>(),</span><br><span class="line">                                           E = Escaped.<span class="built_in">end</span>();</span><br><span class="line">       I != E; ++I) &#123;</span><br><span class="line">    SymbolRef Sym = *I;</span><br><span class="line">    State = State-&gt;<span class="built_in">remove</span>&lt;StreamMap&gt;(Sym);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> State;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第6行，执行了一个自定义检查，以避免考虑对某些预期类型的失效事件的检查，从而启发式地判定函数是否是我们感兴趣的。</p>
<h5 id="4-3-14-eval-Asumme"><a href="#4-3-14-eval-Asumme" class="headerlink" title="4.3.14 eval::Asumme"></a>4.3.14 <code>eval::Asumme</code></h5><p><code>ProgramStateRef evalAssume(ProgramStateRef State, SVal Cond,bool Assumption) const;</code></p>
<p>每当程序状态中出现新的范围约束时，此回调将触发。有了这个回调，checks可以在它们内部存储的符号上有了新的约束时被触发，或者让它们帮助分析器与约束管理器一起“评估”假设，修改程序状态。但是，在使用这个回调之前，最好先看看<code>check::BranchCondition</code>是否足够满足你的需要。</p>
<p>例如，<code>unix.Malloc</code>使用这个回调来查找指向已分配内存的任何符号是否被限制为空指针值。一旦这个符号分解成一个具体的值，再追踪这个符号就没有意义了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProgramStateRef <span class="title">MallocChecker::evalAssume</span><span class="params">(ProgramStateRef State, SVal Cond, <span class="type">bool</span> Assumption)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    RegionStateTy RS = State-&gt;<span class="built_in">get</span>&lt;RegionState&gt;();</span><br><span class="line">    <span class="keyword">for</span> (RegionStateTy::iterator I = RS.<span class="built_in">begin</span>(), E = RS.<span class="built_in">end</span>(); I != E; ++I) &#123;</span><br><span class="line">        ConstraintManager &amp;CMgr = State-&gt;<span class="built_in">getConstraintManager</span>();</span><br><span class="line">        ConditionTruthVal AllocFailed = CMgr.<span class="built_in">isNull</span>(State, I.<span class="built_in">getKey</span>());</span><br><span class="line">        <span class="keyword">if</span> (AllocFailed.<span class="built_in">isConstrainedTrue</span>())</span><br><span class="line">            State = State-&gt;<span class="built_in">remove</span>&lt;RegionState&gt;(I.<span class="built_in">getKey</span>());</span><br><span class="line">    &#125; <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> State;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-3-15-eval-Call"><a href="#4-3-15-eval-Call" class="headerlink" title="4.3.15 eval::Call"></a>4.3.15 <code>eval::Call</code></h5><p><code>bool evalCall ( const CallExpr * CE , CheckerContext &amp;C ) const ;</code></p>
<p>这个回调允许checker对函数调用建模，重载通常的过程间分析机制。当函数的源代码不能用于分析时，它可能对建模特定于领域的库函数有用。</p>
<p>如果checker成功地建模了函数调用，回调函数应该返回true，如果checker更好地依赖分析器核心或其他checker来评估此调用，则返回false。</p>
<p>我们不鼓励使用这个回调，因为任何调用事件只有一个checker可以评估(evaluate)。如果两个或两个以上的checker(可能是由不同的人开发的)意外地评估了相同的功能，那么分析器的行为是未定义的。因此，如果可能的话，应该考虑<code>check::PreCall</code>和<code>check::PostCall</code>，而且大多数时候，它们足够灵活，可以对程序状态的调用效果建模。官方的<code>core.builtin.BuiltinFunctions</code>checker使用这个回调函数来模拟某些编译器内置函数的行为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BuiltinFunctionChecker ::<span class="built_in">evalCall</span>(<span class="type">const</span> CallExpr *CE,</span><br><span class="line">                                       CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FunctionDecl *FD = C.<span class="built_in">getCalleeDecl</span>(CE);</span><br><span class="line">    <span class="keyword">if</span> (!FD)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ProgramStateRef State = C.<span class="built_in">getState</span>();</span><br><span class="line">    <span class="type">const</span> LocationContext *LCtx = C.<span class="built_in">getLocationContext</span>();</span><br><span class="line">    <span class="keyword">switch</span> (FD-&gt;<span class="built_in">getBuiltinID</span>()) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">case</span> Builtin ::BI__builtin_addressof: &#123;</span><br><span class="line">            <span class="built_in">assert</span>(CE-&gt;<span class="built_in">arg_begin</span>() != CE-&gt;<span class="built_in">arg_end</span>());</span><br><span class="line">            SVal X = State-&gt;<span class="built_in">getSVal</span>(*(CE-&gt;<span class="built_in">arg_begin</span>()), LCtx);</span><br><span class="line">            C.<span class="built_in">addTransition</span>(State-&gt;<span class="built_in">BindExpr</span>(CE, LCtx, X));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-实现bug-report-visitors"><a href="#4-4-实现bug-report-visitors" class="headerlink" title="4.4 实现bug report visitors"></a>4.4 实现<code>bug report visitors</code></h4><p>通常，<code>BugReporter</code>能够很好地解释路径敏感的错误是如何被发现的，并将符号执行路径上的所有事件显示给用户。然而，有时你可能希望它标记和显示其他事件。例如，当报告一个二次释放的错误时，你可能希望让用户知道第一个free发生的时间。在这种情况下，你需要实现一个<code>bug report visitor</code>，它将从头到尾遍历bug报告路径（一个<code>ExplodedNode</code>列表），并在整个过程中注入路径诊断片段。</p>
<p><code>bug report visitor</code>的语法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVisitor</span> : <span class="keyword">public</span> BugReporterVisitorImpl&lt;MyVisitor&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Profile</span><span class="params">(llvm::FoldingSetNodeID &amp;ID)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PathDiagnosticPiece *<span class="title">VisitNode</span><span class="params">(<span class="type">const</span> ExplodedNode *N, <span class="type">const</span> ExplodedNode *PrevN, BugReporterContext &amp;BBC, BugReporter &amp;BR)</span></span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="type">const</span> Stmt *S = <span class="comment">/* obtain a statement*/</span>)&#123;</span><br><span class="line">            <span class="function">PathDiagnosticLocation <span class="title">Pos</span><span class="params">(S,BBC.getSourceManager(), N-&gt;getLocationContexst())</span></span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PathDiagnosticEventPiece</span>(Pos, <span class="string">&quot;Message&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你需要实现<code>Profile(…)</code>方法，因为bug visitor将被存储在路径诊断回调的LLVM折叠集中。然后需要实现<code>VisitNode(…)</code>。它应该识别感兴趣的节点，为它构造一个路径诊断并返回，或者如果应该跳过该节点，则返回一个空指针。通过程序点中的语句识别节点并不罕见。在这种情况下，<code>PathDiagnosticLocation</code>类的静态助手方法<code>getStmt(…)</code>应该是有用的:</p>
<p><code>const Stmt *S = PathDiagnosticLocation::getStmt(N);</code></p>
<p>但是请注意，很可能有多个节点对应于同一个语句。</p>
<h4 id="4-5-理解过程间分析"><a href="#4-5-理解过程间分析" class="headerlink" title="4.5 理解过程间分析"></a>4.5 理解过程间分析</h4><p>CSA建模函数调用的方式对于大多数checker来说是相当直接和透明的。分析器建模函数调用的方式通常是：内联调用代码体，紧接着执行被调用的函数（在实参被求值后），直到return，然后完成返回值绑定（如果有返回值），把返回值绑定到环境中的调用语句上，并继续调用函数的分析。</p>
<p>如果分析器无法获得被调用函数的源代码，它会尝试保守地评估函数。在保守求值时，对函数的假设越少越好，通常会出现已知信息失效的情况。</p>
<p>此外，CSAchecker可以通过订阅<code>eval::Call</code>回调函数来覆盖某些函数的求值过程。为了实现某些检查，你可能需要了解内联过程和保守计算过程的某些特性。</p>
<h5 id="4-5-1-保守计算与无效化"><a href="#4-5-1-保守计算与无效化" class="headerlink" title="4.5.1 保守计算与无效化"></a>4.5.1 保守计算与无效化</h5><p>当调用的内联和检查端求值都失败时，分析器将退回到保守求值。这样的求值是相对简单的，因为没有什么真正被求值。相反，分析器需要删除以前已知的、可能已经无效的所有信息。删除这些信息的过程被称为无效化。</p>
<p>失效主要由区域存储处理。函数可能会将未知值写入所有可用的位置，例如全局变量或作为参数传递给它的区域。为了表示这些值，我们创建了新的、不受约束的<code>SymbolConjured</code>类型的符号表达式(这种类型的符号将在5.5.2中详细讨论)，并绑定到区域存储中的无效区域。有两个checker回调可以让你在checker中捕捉无效化事件并采取行动:</p>
<ul>
<li><code>check::PointerEscape</code>让你处理指针符号被传递到保守求值函数的事件。</li>
<li><code>check::RegionChanges</code>允许你观察失效的完整序列，包括一个失效区域的列表。</li>
</ul>
<h5 id="4-5-2-内联和栈帧"><a href="#4-5-2-内联和栈帧" class="headerlink" title="4.5.2 内联和栈帧"></a>4.5.2 内联和栈帧</h5><p>内联函数调用对于分析器来说是一个繁重的操作。每个函数调用每一个新的背景下就需要新建一次模型，被调用函数的上下文相关的爆炸图（可能对于上下文中的变量有不同的值，以及缺乏上下文中的不可达分支）成为当前分析的爆炸图的子图。</p>
<p>内联需要多个前提条件，包括：</p>
<ul>
<li>被调用函数的代码体需要是可获取的</li>
<li>没有checker会通过<code>eval::Call</code>分析函数调用</li>
<li>如果被调用对象的分析达到最大爆炸节点的极限，则被调用对象将永远不会内联，而是保守地计算;</li>
<li>即使支持递归，也只会执行有限数量的嵌套递归调用</li>
</ul>
<p>每当分析器内联一个函数并进入它时，就会创建一个新的<code>StackFrameContext</code>。这个结构是一种<code>LocationContext</code>，它描述了在过程间分析期间进入函数的位置。你可以通过<code>CheckerContext</code>的<code>getStackFrame()</code>方法获得当前的堆栈帧。一般来说你需要知道的是，如果我们在一个内联函数内或在顶部帧，可以使用<code>CheckerContext </code>的一个方便的<code>inTopFrame()</code>方法。</p>
<p>你需要处理堆栈帧的一个常见的情况是<code>check::EndFunction</code>回调函数。这个回调函数在每次从函数返回时触发，但是你需要查看它是分析结束还是仅仅是从堆栈帧弹出。</p>
<p>有时，你可能希望在检查逻辑中依赖符号值的层次结构(参见第5节)。那么你将知道表示函数参数值的符号值将是一个<code>SymbolRegionValue</code>类型的符号用于类型为<code>VarRegion</code>的区域，而这个区域用于类型为<code>ParmVarDecl</code>的<code>decl</code>。然而，对于内联调用，这是不对的。例如，参数可以是一个任意的<code>SVal</code>，在当前调用者上下文中传递给函数。因此，如果你依赖于这些检查，你很可能需要编写额外的检查代码，以了解IPA在当前事件中的状态。</p>
<h4 id="4-6-延伸阅读"><a href="#4-6-延伸阅读" class="headerlink" title="4.6 延伸阅读"></a>4.6 延伸阅读</h4><p>符号执行的原始论文：<br>James C. King. Symbolic execution and program testing. In: Communications of the ACM, vol. 19. N7. pp. 385–394 (1976)</p>
<p>过程间分析：</p>
<p>Precise interprocedural dataflow analysis via graph reachability, T Reps, S Horwitz, and M Sagiv, POPL ’95, <a target="_blank" rel="noopener" href="http://portal.acm.org/citation.cfm?id=199462">http://portal.acm.org/citation.cfm?id=199462</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/Effective-Modern-C++-(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Effective-Modern-C++-(1)/" class="post-title-link" itemprop="url">Effective Modern C++ (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 19:00:00 / Modified: 19:54:17" itemprop="dateCreated datePublished" datetime="2022-05-05T19:00:00+08:00">2022-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-Modern-C/" itemprop="url" rel="index"><span itemprop="name">Effective Modern C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Effective-Modern-C-2-Auto"><a href="#Effective-Modern-C-2-Auto" class="headerlink" title="Effective Modern C++ (2) Auto"></a>Effective Modern C++ (2) Auto</h2><h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This chapter talks about ‘auto’. This keyword is supported from C++11, and is very convenient at most times. However, in some occasions, its behavior may seem just ‘wrong’ to programmers. This chapter has two items, introducing us to auto’s ins and outs.</p>
<h3 id="Item-5-Prefer-auto-to-explicit-type-declarations"><a href="#Item-5-Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Item 5 Prefer auto to explicit type declarations."></a>Item 5 Prefer auto to explicit type declarations.</h3><h5 id="Why-auto-is-good"><a href="#Why-auto-is-good" class="headerlink" title="Why auto is good:"></a>Why <code>auto</code> is good:</h5><ul>
<li>write less</li>
<li>when it comes to holding a closure, it uses as much memory as the closure requires. <ul>
<li><code>std::function</code>, on the contrary, has a fixed size for any given signature, and thus may yield out-of-memory exceptions.</li>
</ul>
</li>
<li>can help reduce uninitialized problems</li>
<li>can be cross-platform.<ul>
<li>e.g. <code>std::vector&lt;int&gt;::size_type</code> becomes 64 bits on 64-bit Windows, while<code>unsigned</code> is still 32 bits.</li>
</ul>
</li>
<li>avoid const-missing in for-range and so on.<ul>
<li>e.g. key part of unordered_map in const. If you write something without a const qualification, it will be copied every time.</li>
</ul>
</li>
<li>enhance readability.</li>
</ul>
<h5 id="Why-auto-is-not-perfect"><a href="#Why-auto-is-not-perfect" class="headerlink" title="Why auto is not perfect:"></a>Why <code>auto</code> is not perfect:</h5><ul>
<li>the deduced type may be “strange” <ul>
<li>e.g. <code>std::initial_list</code></li>
</ul>
</li>
<li>Seen in Item 6</li>
</ul>
<h5 id="other-notes"><a href="#other-notes" class="headerlink" title="other notes:"></a>other notes:</h5><ul>
<li><code>std::function</code> objects can refer to any callable object, i.e. , to anything that can be invoked like a function.</li>
</ul>
<h3 id="Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Item 6 Use the explicitly typed initializer idiom when auto deduces undesired types."></a>Item 6 Use the explicitly typed initializer idiom when <code>auto</code> deduces undesired types.</h3><h5 id="When-auto-zig-zag"><a href="#When-auto-zig-zag" class="headerlink" title="When auto zig-zag:"></a>When <code>auto</code> zig-zag:</h5><ul>
<li><p>lack of the implicit cast</p>
<ul>
<li><code>std::vector&lt;bool&gt;[1]</code>, without <code>bool</code> specified, turns out to be dangling pointers(pointing to temporary objects) on some implementations.</li>
</ul>
</li>
<li><p>invisible proxy class</p>
<ul>
<li><p>just like <code>std::vector::reference</code>,</p>
</li>
<li><p>Expression templates</p>
<ul>
<li>as to numerical operations, if operators returns a proxy for the result instead of the result itself, it would be faster.</li>
</ul>
</li>
<li><p>they are not designed to live longer than a single statement.</p>
</li>
<li><p>should avoid:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> somevar = expression of invisible proxy <span class="keyword">class</span> types.</span><br></pre></td></tr></table></figure>
</li>
<li><p>how to avoid: </p>
<ul>
<li>static_cast&lt;&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Other notes:</p>
<ul>
<li><code>std::vector&lt;bool&gt;</code> is specified to represent its bools in packed form, one bit per bool.</li>
<li>C++ forbids reference to bits.</li>
<li>how to find invisible proxy class:<ul>
<li>function signatures will reflect them: operator returning a reference.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/Effective-Modern-C++-(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Effective-Modern-C++-(2)/" class="post-title-link" itemprop="url">Effective Modern C++ (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-05 19:00:00 / Modified: 19:54:42" itemprop="dateCreated datePublished" datetime="2022-05-05T19:00:00+08:00">2022-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Effective-Modern-C/" itemprop="url" rel="index"><span itemprop="name">Effective Modern C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Effective-Modern-C-2-Auto"><a href="#Effective-Modern-C-2-Auto" class="headerlink" title="Effective Modern C++ (2) Auto"></a>Effective Modern C++ (2) Auto</h2><h3 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h3><p>This chapter talks about ‘auto’. This keyword is supported from C++11, and is very convenient at most times. However, in some occasions, its behavior may seem just ‘wrong’ to programmers. This chapter has two items, introducing us to auto’s ins and outs.</p>
<h3 id="Item-5-Prefer-auto-to-explicit-type-declarations"><a href="#Item-5-Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Item 5 Prefer auto to explicit type declarations."></a>Item 5 Prefer auto to explicit type declarations.</h3><h5 id="Why-auto-is-good"><a href="#Why-auto-is-good" class="headerlink" title="Why auto is good:"></a>Why <code>auto</code> is good:</h5><ul>
<li>write less</li>
<li>when it comes to holding a closure, it uses as much memory as the closure requires. <ul>
<li><code>std::function</code>, on the contrary, has a fixed size for any given signature, and thus may yield out-of-memory exceptions.</li>
</ul>
</li>
<li>can help reduce uninitialized problems</li>
<li>can be cross-platform.<ul>
<li>e.g. <code>std::vector&lt;int&gt;::size_type</code> becomes 64 bits on 64-bit Windows, while<code>unsigned</code> is still 32 bits.</li>
</ul>
</li>
<li>avoid const-missing in for-range and so on.<ul>
<li>e.g. key part of unordered_map in const. If you write something without a const qualification, it will be copied every time.</li>
</ul>
</li>
<li>enhance readability.</li>
</ul>
<h5 id="Why-auto-is-not-perfect"><a href="#Why-auto-is-not-perfect" class="headerlink" title="Why auto is not perfect:"></a>Why <code>auto</code> is not perfect:</h5><ul>
<li>the deduced type may be “strange” <ul>
<li>e.g. <code>std::initial_list</code></li>
</ul>
</li>
<li>Seen in Item 6</li>
</ul>
<h5 id="other-notes"><a href="#other-notes" class="headerlink" title="other notes:"></a>other notes:</h5><ul>
<li><code>std::function</code> objects can refer to any callable object, i.e. , to anything that can be invoked like a function.</li>
</ul>
<h3 id="Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Item 6 Use the explicitly typed initializer idiom when auto deduces undesired types."></a>Item 6 Use the explicitly typed initializer idiom when <code>auto</code> deduces undesired types.</h3><h5 id="When-auto-zig-zag"><a href="#When-auto-zig-zag" class="headerlink" title="When auto zig-zag:"></a>When <code>auto</code> zig-zag:</h5><ul>
<li><p>lack of the implicit cast</p>
<ul>
<li><code>std::vector&lt;bool&gt;[1]</code>, without <code>bool</code> specified, turns out to be dangling pointers(pointing to temporary objects) on some implementations.</li>
</ul>
</li>
<li><p>invisible proxy class</p>
<ul>
<li><p>just like <code>std::vector::reference</code>,</p>
</li>
<li><p>Expression templates</p>
<ul>
<li>as to numerical operations, if operators returns a proxy for the result instead of the result itself, it would be faster.</li>
</ul>
</li>
<li><p>they are not designed to live longer than a single statement.</p>
</li>
<li><p>should avoid:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> somevar = expression of invisible proxy <span class="keyword">class</span> types.</span><br></pre></td></tr></table></figure>
</li>
<li><p>how to avoid: </p>
<ul>
<li>static_cast&lt;&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Other notes:</p>
<ul>
<li><code>std::vector&lt;bool&gt;</code> is specified to represent its bools in packed form, one bit per bool.</li>
<li>C++ forbids reference to bits.</li>
<li>how to find invisible proxy class:<ul>
<li>function signatures will reflect them: operator returning a reference.</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E5%85%B3%E4%BA%8E%E6%A0%87%E7%AD%BE%E5%88%86%E5%8F%91%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E5%85%B3%E4%BA%8E%E6%A0%87%E7%AD%BE%E5%88%86%E5%8F%91%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">关于标签分发的一点记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-26 12:47:00 / Modified: 13:12:46" itemprop="dateCreated datePublished" datetime="2022-04-26T12:47:00+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/working-notes/" itemprop="url" rel="index"><span itemprop="name">working notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工作的时候，听同事提到了“使用类模板偏特化来进行标签分发”的设计思路。虽然在前面设计chiron的插桩方法时，已经实际使用过“标签分发”的想法，但当时只是灵机一动，此时才知道有这样一种概念。因而做一些记录。</p>
<p>本文参考了这篇<a target="_blank" rel="noopener" href="https://www.fluentcpp.com/2018/04/27/tag-dispatching/">blog</a></p>
<h4 id="什么是标签分发（tag-dispatching）"><a href="#什么是标签分发（tag-dispatching）" class="headerlink" title="什么是标签分发（tag dispatching）"></a>什么是标签分发（tag dispatching）</h4><p>在C++中，多态允许同一函数名具有不同的参数类型列表从而形成多态。但相同的参数类型列表是不被允许的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">2</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="number">3</span>; &#125; <span class="comment">// no. redefinition</span></span><br></pre></td></tr></table></figure>

<p>如何解决同样的参数，不同的行为呢？</p>
<p>可以使用标签分发机制，也即定义不同的类型，用以描述该函数所进行的行为类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tag1</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tag2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, tag1 x )</span> </span>&#123; cout &lt;&lt; <span class="number">2</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, tag2 x )</span> </span>&#123; cout &lt;&lt; <span class="number">3</span>; &#125; <span class="comment">// ok. polymorphism</span></span><br></pre></td></tr></table></figure>

<p>不过需要注意的是：如果是无参数的，那么标签就形成了唯一的参数。如果用在构造函数中，需要注意避免歧义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">constructThisWay</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">constructThatWay</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(constructThisWay)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(constructThatWay)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">((MyClass::constructThisWay()))</span></span>; <span class="comment">// MyClass x</span></span><br><span class="line"><span class="function">MyClass <span class="title">y</span><span class="params">(MyClass::constructThisWay())</span></span>;   <span class="comment">// MyClass y(MyClass::constructThisWay (*)()). viewed as a function declaration, taking a function-pointer as parm.</span></span><br><span class="line"><span class="function">MyClass <span class="title">z</span><span class="params">(MyClass::constructThisWay&#123;&#125;)</span></span>; <span class="comment">// uniform initialization.</span></span><br></pre></td></tr></table></figure>

<p>这一点可以通过使用static constructor 或者 uniform initialization 来避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ConstructThisWay</span>&#123;&#125; constructThisWay;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">ConstructThatWay</span>&#123;&#125; constructThatWay;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(ConstructThisWay)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(ConstructThatWay)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">(MyClass::constructThatWay)</span></span>; <span class="comment">// no more a type, but a tag object.</span></span><br></pre></td></tr></table></figure>



<h4 id="何时使用标签分发"><a href="#何时使用标签分发" class="headerlink" title="何时使用标签分发"></a>何时使用标签分发</h4><p>原文提出了这样一种观点，我认可他的观点：</p>
<blockquote>
<p>使用标签分发来给“行为”附魔，而不要给“数据”附魔。</p>
</blockquote>
<p>例如，即使是同样类型，但是传入的数据含义并不相同，不应该使用标签分发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleBad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">buildWithRadius</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">buildWithDiameter</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleBad</span><span class="params">(<span class="type">double</span> radius, buildWithRadius)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleBad</span><span class="params">(<span class="type">double</span> diameter, buildWithDiameter)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleGood</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleGood</span><span class="params">(Radius radius)</span></span>; <span class="comment">// different types.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircleGood</span><span class="params">(Diameter diameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">用宏实现函数多态的一个技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-26 11:07:00 / Modified: 13:16:04" itemprop="dateCreated datePublished" datetime="2022-04-26T11:07:00+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/working-notes/" itemprop="url" rel="index"><span itemprop="name">working notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前的工作中，遇到了这样的问题：</p>
<p>diagnostic engine 限定了location必须valid，否则assertion会出错。</p>
<p>由于diagnostic engine对于信息的处理函数并非void类型，并不能通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loc.<span class="built_in">invalid</span>()) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>来回避。</p>
<p>所以需要在源头上控制有效性。也即，在<code>diag()</code>之前先检查有效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// in Preprocessing</span><br><span class="line">if(loc.valid())</span><br><span class="line">	diag(loc,msg);</span><br><span class="line">// in AST</span><br><span class="line">if(loc.valid())</span><br><span class="line">    checker-&gt;diag(loc,msg);</span><br></pre></td></tr></table></figure>

<p>但在非发布环境中，是不希望直接掩盖掉invalid信息的。所以设计了一个宏来控制是否做location verification，不过和这里没有关系，不做展开。</p>
<p>这时候，一种自然的想法是：如何把这两个函数统一起来？</p>
<p>实质上，它们唯一的区别在于有没有checker，考虑到每一个checker可能具有不同的类型，这里计划直接使用宏来处理（当然，写一个模板也是没有问题的）。</p>
<p>所以说，两个<code>diag</code>函数形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DIAG_TWO_PARM(loc, mes)  <span class="keyword">if</span> (loc.isValid()) diag(loc, mes)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIAG_THREE_PARM(checker, loc, mes) <span class="keyword">if</span> (loc.isValid()) checker-&gt;diag(loc, mes)</span></span><br></pre></td></tr></table></figure>

<p>应该如何统一呢？</p>
<p>这里使用了宏的变参函数来实现：</p>
<p><code>__VA__ARGS</code>即为宏函数中所传入的参数。而我们只需要让<code>n(每个宏函数在函数列表中所处的位置) + n(argc) == const</code> 就可以了。</p>
<p>具体来说，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GET_4TH_PARM(_1,_2,_3,func,...) func</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_B4_DIAG(...) GET_4TH_PARM(__VA_ARGS__, DIAG_THREE_PARM, DIAG_TWO_PARM, ...)(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH3/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-25 19:00:00" itemprop="dateCreated datePublished" datetime="2022-04-25T19:00:00+08:00">2022-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-22 22:01:03" itemprop="dateModified" datetime="2022-05-22T22:01:03+08:00">2022-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH3-基于AST的checker"><a href="#CH3-基于AST的checker" class="headerlink" title="CH3 基于AST的checker"></a>CH3 基于AST的checker</h3><p>很多简单的checker可以直接通过检查语法树并匹配特征来完成。由于不适用path-sensitive 引擎，这样写的checker很快，而且有不错的TP（True Positive）率，但并不能检查极端情况。</p>
<p>这一章我们会讨论基于AST检查的两种路线：<code>AST visitor</code> 和<code>AST matcher</code>。一般来说这两个有一个就够用了，不过有时候也许你会在同一个checker里同时用这两个。</p>
<p>需要说明的是，基于AST的checker并不是CSA的强项所在，尽管CSA里确实有那么几个基于AST的checker。如果你只需要AST的信息，更合适的工具也许是<code>clang-tidy</code>。</p>
<p>不过换个角度说，在path-sensitive引擎中，带着用到基于AST的checker是很正常的。那么更多地了解path-sensitive所订阅的事件背后的语法也是很有必要的。于是，这一章我们会学习如何写只用AST的checker，不过相关的技术其实也可以迁移到path-sensitive checker中去，所以掌握它们其实很有用。</p>
<h4 id="3-1-非路径敏感checker的回调函数"><a href="#3-1-非路径敏感checker的回调函数" class="headerlink" title="3.1 非路径敏感checker的回调函数"></a>3.1 非路径敏感checker的回调函数</h4><p>正如前面提到过的，如果一个path-sensitive checker都没有，path-sensitive引擎是不会启动的，速度会快很多。同样，因为引擎没有启动，而很多数据结构都不会被建立。因而，能用的回调函数接口并不是很多。能用的里面，比较有用的两个分别是<code>check::EndOfTranslationUnit</code> 和 <code>check::ASTCode Body</code>。</p>
<h5 id="3-1-1-check-EndOfTranslationUnit"><a href="#3-1-1-check-EndOfTranslationUnit" class="headerlink" title="3.1.1 check::EndOfTranslationUnit"></a>3.1.1 check::EndOfTranslationUnit</h5><p>原型为： <code>void checkEndOfTranslationUnit(const TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;BR) const</code>;</p>
<p>在这个回调函数中，程序的整个AST是可以拿到的。</p>
<p>访问整个AST的入口，也就是整个翻译单元（Translation Unit）的声明，是直接以参数形式传入的。</p>
<p>这个回调函数的使用场景通常是：要检查的不只是可执行代码，还包括各种声明。</p>
<h5 id="3-1-2-check-ASTCodeBody"><a href="#3-1-2-check-ASTCodeBody" class="headerlink" title="3.1.2 check::ASTCodeBody"></a>3.1.2 check::ASTCodeBody</h5><p>原型为：<code>void checkASTCodeBody(const Decl* D, AnalysisManager &amp;AM, BugReporter &amp;BR) const;</code></p>
<p>在这个回调函数中，每次调用将会返回函数的声明。其code body是分析器通常会需要分析的，可以通过<code>D-&gt;getBody()</code>来获得。</p>
<p>这个回调函数的使用场景通常是：要检查的只是可执行代码。</p>
<h5 id="3-1-3-check-ASTDecl-lt-T-gt"><a href="#3-1-3-check-ASTDecl-lt-T-gt" class="headerlink" title="3.1.3 check::ASTDecl&lt;T&gt;"></a>3.1.3 check::ASTDecl&lt;T&gt;</h5><p>原型为：<code>void checASTDecl(const T* D, AnalysisManager &amp;AM, BugReporter &amp;BR) const;</code></p>
<p>这个回调函数被用于检查所有AST上类型为<code>T</code>的声明。例如：寻找所有的<code>VarDecl</code>，或者所有的<code>FieldDecl</code>。这通常是declaration Visitor的一种便捷替代。</p>
<h4 id="3-2-AST-Visitors"><a href="#3-2-AST-Visitors" class="headerlink" title="3.2 AST Visitors"></a>3.2 AST Visitors</h4><p>AST visitor是访问Clang的语法树的最简单的方法。clang提供了数量极多、语法相近的visitor。有两类有用的visitor：</p>
<ul>
<li><code>ConstStmtVisitor</code>，用于检查代码主体。</li>
<li><code>ConstDeclVisitor</code>，检查代码主体之外的声明，例如全局变量。</li>
</ul>
<p>想要实现一个Visitor，你需要继承一个它的类，并实现所需要的针对不同AST节点的回调函数需要注意的是，即使没有实现针对特定类型的节点的回调函数，如果实现了针对其基础类型的回调函数，它也会被访问到。</p>
<p>例如，即使没有实现<code>CXXOperatorCallExpr</code>，它也会因为以下中的任意一个被实现而被访问：</p>
<ul>
<li><code>VisitCallExpr()</code></li>
<li><code>VisitExpr()</code></li>
<li><code>VisitStmt()</code></li>
</ul>
<h5 id="3-2-1-实现一个简单的statement-visitor"><a href="#3-2-1-实现一个简单的statement-visitor" class="headerlink" title="3.2.1 实现一个简单的statement visitor"></a>3.2.1 实现一个简单的statement visitor</h5><p>从一个简单的例子开始，我们看看我们能不能使用AST visitor来重写一下<code>MainCallChecker</code>。</p>
<p>第一步，我们来声明AST visitor。visitor保存有用以抛出报告的<code>BugReporter</code>的引用，以及用于提供位置信息的当前的<code>AnalysisDeclContext</code>。后者包裹起了我们在分析的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namesapce&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WalkAST</span>: <span class="keyword">public</span> ConstStmtVisitor&lt;WalkAST&gt;&#123;</span><br><span class="line">        BugReporter &amp;BR;</span><br><span class="line">        AnalysisDeclContext *ADC;</span><br><span class="line">      </span><br><span class="line">        <span class="function">Void <span class="title">VisitChildren</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">WalkAST</span>(BugReporter &amp;Reporter, AnalysisDeclContext *Context): <span class="built_in">BR</span>(Reporter), <span class="built_in">ADC</span>(Context) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">VisitStmt</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">VisitCallExpr</span><span class="params">(<span class="type">const</span> CallExpr *CE)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个visitor定义了两个public的回调函数：<code>VisitCallExpr(...)</code>用于处理函数调用表达式，以及<code>VisitStmt(...)</code>用于处理其它的statement。</p>
<p>这些回调函数有一个共同点：他们在结束访问自身的statement之后，需要访问子statement。这种操作我们切分到<code>VisitChildren(...)</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WalkAST::VisitChildren</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Stmt::const_child_iterator I = S-&gt;<span class="built_in">child_begin</span>(), E=<span class="built_in">child_end</span>(); I!=E; ++I)</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">const</span> Stmt *Child = *I)</span><br><span class="line">            <span class="built_in">Visit</span>(Child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 于是，<code>VisitStmt</code>除了<code>VisitChildren</code>以外不需要做别的了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WalkAST::VisitStmt</span><span class="params">(<span class="type">const</span> Stmt *S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">VisitChildren</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数checker的逻辑被存在<code>VisitCallExpr(...)</code>中。我们获取当前所调用的函数的标识符，看看它是否恰巧是”main”。如果是，那么我们就抛出一个path-sensitive的report。注意，由于没有可用的<code>CheckerContext</code>包裹，所以需要直接访问<code>BugReporter</code>；而且获取位置信息也有点麻烦。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> WalkAST ::<span class="built_in">VisitCallExpr</span>(<span class="type">const</span> CallExpr *CE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> FunctionDecl *FD = CE-&gt;<span class="built_in">getDirectCallee</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = FD-&gt;<span class="built_in">getIdentifier</span>())</span><br><span class="line">            <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">                SourceRange R = CE-&gt;<span class="built_in">getSourceRange</span>();</span><br><span class="line">                PathDiagnosticLocation ELoc = PathDiagnosticLocation ::<span class="built_in">createBegin</span>(</span><br><span class="line">                    CE, BR.<span class="built_in">getSourceManager</span>(), ADC);</span><br><span class="line">                BR.<span class="built_in">EmitBasicReport</span>(ADC-&gt;<span class="built_in">getDecl</span>(), <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;Call to main&quot;</span>, ELoc, R);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">VisitChildren</span>(CE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是visitor的实现。现在我们就只需要创建一个，然后给它一些代码来访问。既然“所有代码”是一个declaration而不是一个statement，我们选择订阅<code>check::ASTCodeBody</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallCheckerAST</span> : <span class="keyword">public</span> Checker&lt;check::ASTCodeBody&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkASTCodeBody</span><span class="params">(<span class="type">const</span> Decl *D, AnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BugReporter &amp;B)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MainCallCheckerAST ::<span class="built_in">checkASTCodeBody</span>(<span class="type">const</span> Decl *D, AnalysisManager &amp;AM,BugReporter &amp;BR) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="function">WalkAST <span class="title">Walker</span><span class="params">(BR, AM.getAnalysisDeclContext(D))</span></span>;</span><br><span class="line">    Walker.<span class="built_in">Visit</span>(D-&gt;<span class="built_in">getBody</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，这个visitor从包含了函数体的compound statement开始，下降到其中的子statement。</p>
<p>到此为止checker就准备好了。但是对前面的例子它并不会报错，因为我们只检查直接函数调用，而不检查通过函数指针的调用。所以我们写一个新的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">main</span>(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// call to main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-合并statement-和declaration-的visitor"><a href="#3-2-2-合并statement-和declaration-的visitor" class="headerlink" title="3.2.2 合并statement 和declaration 的visitor"></a>3.2.2 合并statement 和declaration 的visitor</h5><p>如果需要在内部和并这两种visitor以同时访问statement和declaration，就同时继承这两个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WalkAST</span> : <span class="keyword">public</span> ConstStmtVisitor&lt;WalkAST&gt;,</span><br><span class="line"><span class="keyword">public</span> ConstDeclVisitor&lt;WalkAST&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ConstStmtVisitor&lt;WalkAST&gt;::Visit;</span><br><span class="line">    <span class="keyword">using</span> ConstDeclVisitor&lt;WalkAST&gt;::Visit;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-AST-matcher"><a href="#3-3-AST-matcher" class="headerlink" title="3.3 AST matcher"></a>3.3 AST matcher</h4><p>AST matcher 是在AST上寻找简单代码模式的新接口。它允许对代码的模式特征编写极其简洁的声明式定义，几乎和用自然语言的文字描述它们一样短。并提供了一个对应操作的接口。 AST matcher更适合于简单的代码模式特征，因为其简单性和代码可读性，所以它并不像AST访问者那样无所不能。  </p>
<h5 id="3-3-1-实现一个简单的AST-matcher"><a href="#3-3-1-实现一个简单的AST-matcher" class="headerlink" title="3.3.1 实现一个简单的AST matcher"></a>3.3.1 实现一个简单的AST matcher</h5><p>我们看看我们如何用AST matcher来改写<code>MainCallChecker</code>：</p>
<p>首先写一个matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))). <span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>完整的检查器逻辑现在只需要写一行代码！剩下的就是编写检查程序并抛出错误报告。留神<code>bind(…)</code>命令是如何为应用它的AST节点分配名称的，以便将来参考。  </p>
<p>我们需要做的第一件事是定义匹配器回调。 每当checker找到一些东西时，就会触发这个回调。 这个回调需要继承<code>MatchFinder::MatchCallback</code>并实现名为<code>run(…)</code>的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Callback</span> : <span class="keyword">public</span> MatchFinder ::MatchCallback &#123;</span><br><span class="line">        BugReporter &amp;BR;</span><br><span class="line">        AnalysisDeclContext *ADC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">const</span> MatchFinder ::MatchResult &amp;Result)</span></span>;</span><br><span class="line">        <span class="built_in">Callback</span>(BugReporter &amp;Reporter, AnalysisDeclContext *Context)</span><br><span class="line">            : <span class="built_in">BR</span>(Reporter), <span class="built_in">ADC</span>(Context) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>理想情况下，唯一需要做的就是抛出一个错误报告。不过matcher并不能永远写清楚逻辑细节，所以留一些检查工作在回调函数中也是很正常的事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Callback::run</span><span class="params">(<span class="type">const</span> MatchFinder ::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> CallExpr *CE = Result.Nodes.<span class="built_in">getStmtAs</span>&lt;CallExpr&gt;(<span class="string">&quot;call&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(CE);</span><br><span class="line">    SourceRange R = CE-&gt;<span class="built_in">getSourceRange</span>();</span><br><span class="line">    PathDiagnosticLocation ELoc =</span><br><span class="line">        PathDiagnosticLocation ::<span class="built_in">createBegin</span>(CE, BR.<span class="built_in">getSourceManager</span>(), ADC);</span><br><span class="line">    BR.<span class="built_in">EmitBasicReport</span>(ADC-&gt;<span class="built_in">getDecl</span>(), <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;Call to main&quot;</span>, ELoc, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在毁掉函数中，我们拿到了call expression的名字“call”（正是我们在checker）中通过<code>bind()</code>定义的。在matcher中，我们确信这些调用表达式是存在的，所以我们可以进行断言。</p>
<p>然后该去定义checker了。这次我们试试整TU的匹配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallCheckerMatchers</span> : <span class="keyword">public</span> Checker&lt;check ::EndOfTranslationUnit&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkEndOfTranslationUnit</span><span class="params">(<span class="type">const</span> TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;B)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>最后，在回调checker中，我们需要构建matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainCallCheckerMatchers::checkEndOfTranslationUnit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TranslationUnitDecl *TU, AnalysisManager &amp;AM, BugReporter &amp;B)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    MatchFinder F;</span><br><span class="line">    <span class="function">Callback <span class="title">CB</span><span class="params">(B, AM.getAnalysisDeclContext(TU))</span></span>;</span><br><span class="line">    F.<span class="built_in">addMatcher</span>(</span><br><span class="line">        <span class="built_in">stmt</span>(<span class="built_in">hasDescendant</span>(</span><br><span class="line">            <span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))).<span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>))),</span><br><span class="line">        &amp;CB);</span><br><span class="line">    F.<span class="built_in">matchAST</span>(AM.<span class="built_in">getASTContext</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>matchAST(...)</code>方法会match整个TU的AST。至此为止，整个checker就写好了。</p>
<p>从<code>AnalysisManager</code>中获得的<code>ASTContext</code>，包含了整个程序的AST，以及关于AST的各种元信息，例如编译期间强加的特定于实现的特征（implementation-specific traits）。</p>
<h5 id="3-3-2-复用matcher"><a href="#3-3-2-复用matcher" class="headerlink" title="3.3.2 复用matcher"></a>3.3.2 复用matcher</h5><p>如果一个子特征在matcher中被重复使用，可以保存并复用。例如，下面的例子中，TypeM就是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeMatcher TypeM = <span class="built_in">templateSpecializationType</span>(). <span class="built_in">bind</span>(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">DeclarationMatcher VarDeclM = <span class="built_in">varDecl</span>(<span class="built_in">hasType</span>(TypeM)). <span class="built_in">bind</span>(<span class="string">&quot;decl&quot;</span>);</span><br><span class="line">StatementMatcher TempObjM = <span class="built_in">temporaryObjectExpr</span>(<span class="built_in">hasType</span>(TypeM )).<span class="built_in">bind</span>(<span class="string">&quot;stmt&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="3-3-3-定义定制化matcher"><a href="#3-3-3-定义定制化matcher" class="headerlink" title="3.3.3 定义定制化matcher"></a>3.3.3 定义定制化matcher</h5><p>有时，单纯组合起预定义的checker不足以实现所需的检查。在这种情况下，可以实现一个自定义AST匹配器。这只需要几行代码，很多例子可以在<code>ASTMatchers.h</code>中找到。 在checker中实现自定义的AST matcher时，需要将其放入<code>clang::ast_matchers</code>命名空间。 下面的例子定义了一个自定义声明匹配器，它匹配声明为Union而不是Struct的<code>RecordDecl</code>节点:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> clang&#123;</span><br><span class="line">    <span class="keyword">namespace</span> ast_matchers&#123;</span><br><span class="line">        <span class="built_in">AST_MATCHER</span>(RecordDecl, isUnion)&#123;</span><br><span class="line">            <span class="keyword">return</span> Node.<span class="built_in">isUnion</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-匹配特定的statement"><a href="#3-3-4-匹配特定的statement" class="headerlink" title="3.3.4 匹配特定的statement"></a>3.3.4 匹配特定的statement</h5><p>正如之前所提到的，<code>matchAST(...)</code>匹配整个TU的AST。不过有时候只想要AST的特定一部分，那么可以试试<code>match(...)</code>方法。</p>
<p>举例来说，我们试试用<code>check::ASTCodeBody</code>来实现<code>MainCallChecker</code>。不过，<code>match(...)</code>会匹配statement本身，而<code>matchAST(...)</code>会匹配自身和子statement，所以我们要修改我们的matcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainCallCheckerMatchers::checkASTCodeBody</span><span class="params">(<span class="type">const</span> Decl *D,AnalysisManager &amp;AM,BugReporter &amp;BR)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    MatchFinder F;</span><br><span class="line">    <span class="function">Callback <span class="title">CB</span><span class="params">(BR, AM.getAnalysisDeclContext(D))</span></span>;</span><br><span class="line">    F.<span class="built_in">addMatcher</span>(<span class="built_in">stmt</span>(<span class="built_in">hasDescendant</span>(<span class="built_in">callExpr</span>(<span class="built_in">callee</span>(<span class="built_in">functionDecl</span>(<span class="built_in">hasName</span>(<span class="string">&quot;main&quot;</span>)))).<span class="built_in">bind</span>(<span class="string">&quot;call&quot;</span>))),&amp;CB);</span><br><span class="line">    F.<span class="built_in">match</span>(*(D-&gt;<span class="built_in">getBody</span>()), AM.<span class="built_in">getASTContext</span>()); <span class="comment">// wrong in original text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-常量折叠"><a href="#3-4-常量折叠" class="headerlink" title="3.4 常量折叠"></a>3.4 常量折叠</h4><p>从表达式的AST中并不容易看出它实际上代表一个常量值。一个表达式可能包含对常量变量的类型转换和引用，将其折叠为实际值是不那么容易的。 Clang中有一个现成的解决方案：只需使用Expr的<code>EvaluateAsInt(…)</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Expr *E =<span class="comment">/* some AST expression you are interested in */</span> </span><br><span class="line">    llvm::APSInt Result;</span><br><span class="line"><span class="keyword">if</span> (E-&gt;<span class="built_in">EvaluateAsInt</span>(Result, ACtx,Expr::SE_AllowSideEffects)) &#123; </span><br><span class="line">    <span class="comment">/* we managed to obtain the value of the expression */</span></span><br><span class="line">    <span class="type">uint64_t</span> IntResult = Result.<span class="built_in">getLimitedValue</span>();   <span class="comment">/* ... */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">/* the expression doesn ’t fold to into a constant value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-延伸阅读"><a href="#3-5-延伸阅读" class="headerlink" title="3.5 延伸阅读"></a>3.5 延伸阅读</h4><p><a target="_blank" rel="noopener" href="http://llvm.org/devmtg/2013-04/videos/klimek-vhres.mov">http://llvm.org/devmtg/2013-04/videos/klimek-vhres.mov</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/LibASTMatchersReference.html">http://clang.llvm.org/docs/LibASTMatchersReference.html</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Stmt.html">http://clang.llvm.org/doxygen/classclang_1_1Stmt.html</a> </p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Decl.html">http://clang.llvm.org/doxygen/classclang_1_1Decl.html</a></p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/classclang_1_1Type.html">http://clang.llvm.org/doxygen/classclang_1_1Type.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH2/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-25 17:14:18 / Modified: 17:14:36" itemprop="dateCreated datePublished" datetime="2022-04-25T17:14:18+08:00">2022-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH2-checker的分类-lt-gt-程序的表示方法"><a href="#CH2-checker的分类-lt-gt-程序的表示方法" class="headerlink" title="CH2 checker的分类 &lt;-&gt; 程序的表示方法"></a>CH2 checker的分类 &lt;-&gt; 程序的表示方法</h3><p>在开发一个checker之前，你首先要确定，是需要一个path-sensitive的checker，还是只在语法层面检查就够了。</p>
<p>path-sensitive的检查通常比编译本身要慢很多倍；这其中，绝大多数时间消耗是因为内核需要构建必要的数据结构。checker本身通常意义上是轻量的，除非其中包含了过大过重的运算量。所以，需要抉择的是「是否引入path-sensitive的checker」，而不需要在之后考虑「再引入一个path-sensitive的checker会有多大负担」。</p>
<p>与之相对，如果只是检查语法(syntax)，会和编译过程一样迅速，甚至更快（因为不需要产生目标代码），不过收集的可用信息也会更少。</p>
<p>想要理解这两种checker的区别，最简单的就是看它们是如何表示程序本身的。</p>
<p>我们以下面这段代码为例，从其对应的AST(Abstract-Syntax-Tree, 抽象语法树)，CFG(Control-Flow-Graph, 控制流图)，EG(Exploded-Graph, 爆炸图)来深入探讨：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y, z;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        y = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        z = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-抽象语法树（Abstract-Syntax-Tree）"><a href="#2-1-抽象语法树（Abstract-Syntax-Tree）" class="headerlink" title="2.1 抽象语法树（Abstract Syntax Tree）"></a>2.1 抽象语法树（Abstract Syntax Tree）</h4><p>clang的抽象语法树是由编译器前端生成的一种结构，是一种程序的中间表示（IR, Intermediate Representation）。二进制代码生成是在AST上进行的。与GCC的C&#x2F;C++ 编译器所产生的AST不同，clang的AST不仅有正确编译程序所必要的信息，还有关于程序源码的完整信息，包括：每个树上的元素在源代码里的位置、在原代码中是如何撰写的（甚至预处理之前是如何撰写的）。这使得AST可以作为源代码层面分析程序的易用框架。</p>
<p>以下是test.c的AST:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ clang-7 -cc1 -ast-dump /tmp/foo.cpp</span><br><span class="line">TranslationUnitDecl 0x32173f8 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt;</span><br><span class="line">|-TypedefDecl 0x3217cd0 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __int128_t <span class="string">&#x27;__int128&#x27;</span></span><br><span class="line">| `-BuiltinType 0x3217990 <span class="string">&#x27;__int128&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3217d38 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __uint128_t <span class="string">&#x27;unsigned __int128&#x27;</span></span><br><span class="line">| `-BuiltinType 0x32179b0 <span class="string">&#x27;unsigned __int128&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3218078 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __NSConstantString <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">| `-RecordType 0x3217e20 <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">|   `-CXXRecord 0x3217d88 <span class="string">&#x27;__NSConstantString_tag&#x27;</span></span><br><span class="line">|-TypedefDecl 0x32517e0 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_ms_va_list <span class="string">&#x27;char *&#x27;</span></span><br><span class="line">| `-PointerType 0x32180d0 <span class="string">&#x27;char *&#x27;</span></span><br><span class="line">|   `-BuiltinType 0x3217490 <span class="string">&#x27;char&#x27;</span></span><br><span class="line">|-TypedefDecl 0x3251b18 &lt;&lt;<span class="string">invalid sloc&gt;&gt; &lt;invalid</span> sloc&gt; implicit __builtin_va_list <span class="string">&#x27;__va_list_tag [1]&#x27;</span></span><br><span class="line">| `-ConstantArrayType 0x3251ac0 <span class="string">&#x27;__va_list_tag [1]&#x27;</span> 1 </span><br><span class="line">|   `-RecordType 0x32518d0 <span class="string">&#x27;__va_list_tag&#x27;</span></span><br><span class="line">|     `-CXXRecord 0x3251830 <span class="string">&#x27;__va_list_tag&#x27;</span></span><br><span class="line">`-FunctionDecl 0x3251c40 &lt;/tmp/foo.cpp:1:1, line:7:1&gt; line:1:6 foo <span class="string">&#x27;void (int)&#x27;</span></span><br><span class="line">  |-ParmVarDecl 0x3251b80 &lt;col:10, col:14&gt; col:14 used x <span class="string">&#x27;int&#x27;</span></span><br><span class="line">  `-CompoundStmt 0x3252098 &lt;col:16, line:7:1&gt;</span><br><span class="line">    |-DeclStmt 0x3251e30 &lt;line:2:5, col:13&gt;</span><br><span class="line">    | |-VarDecl 0x3251d40 &lt;col:5, col:9&gt; col:9 used y <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | `-VarDecl 0x3251db8 &lt;col:5, col:12&gt; col:12 used z <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    |-IfStmt 0x3251f40 &lt;line:3:5, line:4:13&gt;</span><br><span class="line">    | |-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">    | |-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br><span class="line">    | |-BinaryOperator 0x3251ea8 &lt;line:3:8, col:13&gt; <span class="string">&#x27;bool&#x27;</span> <span class="string">&#x27;==&#x27;</span></span><br><span class="line">    | | |-ImplicitCastExpr 0x3251e90 &lt;col:8&gt; <span class="string">&#x27;int&#x27;</span> &lt;LValueToRValue&gt;</span><br><span class="line">    | | | `-DeclRefExpr 0x3251e48 &lt;col:8&gt; <span class="string">&#x27;int&#x27;</span> lvalue ParmVar 0x3251b80 <span class="string">&#x27;x&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | | `-IntegerLiteral 0x3251e70 &lt;col:13&gt; <span class="string">&#x27;int&#x27;</span> 0</span><br><span class="line">    | |-BinaryOperator 0x3251f18 &lt;line:4:9, col:13&gt; <span class="string">&#x27;int&#x27;</span> lvalue <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    | | |-DeclRefExpr 0x3251ed0 &lt;col:9&gt; <span class="string">&#x27;int&#x27;</span> lvalue Var 0x3251d40 <span class="string">&#x27;y&#x27;</span> <span class="string">&#x27;int&#x27;</span></span><br><span class="line">    | | `-IntegerLiteral 0x3251ef8 &lt;col:13&gt; <span class="string">&#x27;int&#x27;</span> 5</span><br><span class="line">    | `-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">    `-IfStmt 0x3252060 &lt;line:5:5, line:6:13&gt;</span></span><br><span class="line"><span class="string">      |-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br><span class="line">      |-&lt;&lt;&lt;<span class="string">NULL&gt;&gt;&gt;</span></span><br><span class="line"><span class="string">      |-UnaryOperator 0x3251fd0 &lt;line:5:8, col:9&gt; &#x27;bool&#x27; prefix &#x27;!&#x27; cannot overflow</span></span><br><span class="line"><span class="string">      | `-ImplicitCastExpr 0x3251fb8 &lt;col:9&gt; &#x27;bool&#x27; &lt;IntegralToBoolean&gt;</span></span><br><span class="line"><span class="string">      |   `-ImplicitCastExpr 0x3251fa0 &lt;col:9&gt; &#x27;int&#x27; &lt;LValueToRValue&gt;</span></span><br><span class="line"><span class="string">      |     `-DeclRefExpr 0x3251f78 &lt;col:9&gt; &#x27;int&#x27; lvalue ParmVar 0x3251b80 &#x27;x&#x27; &#x27;int&#x27;</span></span><br><span class="line"><span class="string">      |-BinaryOperator 0x3252038 &lt;line:6:9, col:13&gt; &#x27;int&#x27; lvalue &#x27;=&#x27;</span></span><br><span class="line"><span class="string">      | |-DeclRefExpr 0x3251ff0 &lt;col:9&gt; &#x27;int&#x27; lvalue Var 0x3251db8 &#x27;z&#x27; &#x27;int&#x27;</span></span><br><span class="line"><span class="string">      | `-IntegerLiteral 0x3252018 &lt;col:13&gt; &#x27;int&#x27; 6</span></span><br><span class="line"><span class="string">      `-&lt;&lt;&lt;NULL</span>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>阅读AST的过程与阅读源程序是很类似的，注释中标明了很多源代码上不那么明显可见的语义（semantic）。例如，你可以直接读出，第3行的x是作为foo(…)函数的参数传入的，而第4行的y是一个在第2行声明的局部变量。</p>
<p>不过，在构造AST的过程中，编译器并不会试图理解或建模程序究竟在做什么。它不会构建不同分支选择所导致的不同的程序路径，更不会去试图预测不同的分支会发生什么。</p>
<p>基于AST能做的最好的事情莫过于检测不想要的代码模式（code pattern）。例如，可能我们在某个项目中不允许C风格的强制类型转换。那么我们就可以在语法树上所有的C风格强制类型转换节点上报警。更复杂一点的例子，比如“要求所有函数的返回值都应当进行检验”。</p>
<p>在CSA的默认发行版中，<code>security.InsecureAPI</code>分类中的许多checker都是AST checker的好例子。</p>
<p>不过，如果你想要检查点复杂的情况，AST checker的能力没有那么强。比如说在检查除零时，它可以检查出<code>y = x / 0;</code> 但很难查出<code>z=0; ...y = x/z;</code> 这种时候，就需要一些更强力的工具了。</p>
<h4 id="2-2-控制流图（Control-Flow-Graph）"><a href="#2-2-控制流图（Control-Flow-Graph）" class="headerlink" title="2.2 控制流图（Control Flow Graph）"></a>2.2 控制流图（Control Flow Graph）</h4><p>控制流图使用图来表示程序执行中所有可能经过的路径。CFG 是为每个函数体单独构造的，每一个节点代表一个内部不包含任何分支的基本语句块（这意味着其中是顺序执行的）。每个基本块以“终结语句”结束，“终结语句”要么是一个分支语句，要么是函数的return。这个基本块的出边会连到根据“终结语句”的条件判断可达的其它基本语句块。</p>
<p>CSA中有一个简单的输出CFG的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$clang</span> -cc1 -analyze -analyzer-checker=debug.DumpCFG test.c</span><br></pre></td></tr></table></figure>



<p>或者（需要Graphviz，生成dot图，且需要DEBUG的clang）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./bin/clang  -cc1 -analyze -analyzer-checker=debug.ViewCFG -analyzer-viz-egraph-graphviz test.C</span><br><span class="line"><span class="variable">$dot</span> xxxx.dot -Tpng -o test.png</span><br></pre></td></tr></table></figure>



<p>这里是源码意义上的CFG。如果想要查看中间码的CFG，可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$clang</span> -S -emit-llvm test.c -o test.bc</span><br><span class="line"><span class="variable">$opt</span> -view-cfg test.bc</span><br><span class="line"><span class="variable">$dot</span> xxxx.dot -Tpng -o test.png</span><br></pre></td></tr></table></figure>



<p>基于CFG的分析有利于创建旨在做安全检查的checker，尤其是那些需要考虑程序所有的可能路径的。举例来说，如果你想要确保某个特定的分支条件永远算出来是<code>false</code>，使得其下的某些代码是不可达的，那么你将不得不接触这个条件中的每一个变量的定义——这时候，CFG就恰是你所需要的。</p>
<p>CFG可以很容易从AST构建。但是，基于CFG的分析通常不是很容易实现，因为CFG并不提供实时的数据流分析。为了达到这个目的，需要写额外的代码。Clang框架本身提供了一些“开箱即用”的基于CFG的checker，例如<code>LivenessAnalysis</code> （这也是CSA内存模型中的关键一点）。</p>
<p>在CSA的默认发行版中，<code>deadcode.DeadStores</code>是一个很好的基于CFG的checker的例子。</p>
<p>有时候，基于CFG的分析会和path-sensitive的分析组合使用：用path-sensitive的部分来检查潜在的缺陷位置，再用基于CFG的启发式算法来检查相连的其他路径以提高真阳性率（True Positive Rate）。<code>deadcode.UnreachableCode</code>就是一个结合path-sensitive和CFG的很好例子。</p>
<p>但是，细心的读者会在foo()函数的CFG中迅速发现一个缺陷：CFG无法显示分支条件的相关性。实际上<code>x==0</code>和<code>!x</code>的真值是相同的，故而两个分支条件注定同真或同假，所以从程序开始达到结尾实际上只存在两条路径：</p>
<ul>
<li>要么<code>x==0</code>，串行执行整个代码给y、z赋值。</li>
<li>要么<code>x!=0</code>，直接跳转到结尾。</li>
</ul>
<h4 id="2-3-爆炸图（Exploded-Graph）"><a href="#2-3-爆炸图（Exploded-Graph）" class="headerlink" title="2.3 爆炸图（Exploded Graph）"></a>2.3 爆炸图（Exploded Graph）</h4><p>CSA的爆炸图是path-sensitive分析器引擎的基础数据结构。分析器核心试图“解释”程序代码，并分别处理通过CFG的所有不同路径（即使它们通过相同的语句或基本语句块），因此叫作“爆炸”（explode）。 爆炸图包含所有由分析器引擎探索过的路径，并保有每个语句中每个路径上的程序状态的信息。图中的每个点（我们称作“爆炸点”），是一个二元组：<code>（程序当前状态，当前被分析的程序节点）</code>。</p>
<p>你可以这样使用这个checker来查看爆炸图：</p>
<p><code>clang -cc1 -analyze -analyzer-checker=debug.ViewExplodedGraph test.c</code></p>
<p>实际上，爆炸图通常很大很大，例如<code>foo()</code>产生的爆炸图会有超过50个节点。当到达一个CFG中的终结符时，比如一个if语句，因为不确定条件判断的结果，所以并不知道会走向哪条分支。在爆炸图中，就会兵分两路，在每条路上，都假定进入该条路的条件成立。例如<code>if(x)</code>中，<code>then-branch</code>的条件是<code>x ∈ [0,0]</code>，而<code>else-branch</code>的条件是<code> x ∈ [INT_MIN,-1] ∪ [1, INT_MAX]</code>。这个条件会被收集起来，直到这个符号达到生命周期的尽头。</p>
<p>例如，在已经收集了<code>x==0</code>条件的前提下，<code>!x</code>的真值是可判定的，而不再是一个未定值。而此时关于<code>y</code>的信息则因为y已经到达生命周期的尽头而不再存储。</p>
<p>爆炸图中存储了详尽的信息，包含分析器核心对程序执行所能做出的”最佳假设”。 此外，与基于AST和CFG的分析不同，path-sensitive的CSA checker很少被动地读取爆炸图，而是积极地参与其构建，添加自己的节点、绑定(binding)、假设、作特定于检查器的标记，并根据自己的意愿在分解图中分隔路径。</p>
<h4 id="2-4-延伸阅读"><a href="#2-4-延伸阅读" class="headerlink" title="2.4 延伸阅读"></a>2.4 延伸阅读</h4><p>关于AST：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html">https://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/CSA%20Guide%20CN%20CH1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/25/CSA%20Guide%20CN%20CH1/" class="post-title-link" itemprop="url">Clang Static Analyzer · Checker Developer's Guide [CN] (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-25 11:59:45 / Modified: 12:04:45" itemprop="dateCreated datePublished" datetime="2022-04-25T11:59:45+08:00">2022-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CH-1-关于CSA-Clang-Static-Analyzer-的简介"><a href="#CH-1-关于CSA-Clang-Static-Analyzer-的简介" class="headerlink" title="CH 1 关于CSA(Clang Static Analyzer)的简介"></a>CH 1 关于CSA(Clang Static Analyzer)的简介</h3><p>以LLVM的体系结构为基础，Clang编译器的功能远远不只是一个将C&#x2F;C++&#x2F;Obj-C代码转换成二进制可执行文件那么简单。Clang允许用户在编译过程上“挂钩”，并借此得到编译器在编译的每个阶段所产生的数据的详细信息。换句话说，如果你想了解更多关于你写的程序的信息，那么最好就直接去问编译器——而clang是愿意回答你的问题的，前提是你问了正确的问题。</p>
<p>clang工具的应用之一，是自动寻找程序中的缺陷，并提供警告。很多警告是你的编译器本身可能不会提供的。比如说，<code>clang-tidy</code>会通过检查程序中的语法来寻找代码风格、安全性或可移植性上的问题。</p>
<p>CSA是另一个寻找程序缺陷的工具。在源码基础上，CSA会在不编译的基础上虚拟执行程序中的一部分（就如同阅读源码并想象如果跑起来是什么样），并报告那些虚拟执行中出现的问题。因为任何真实程序的实际行为都取决于外部因素，例如输入值、随机数和库组件的行为(对于这些因素，源代码并不总是可获取的)，所以分析器引擎用<strong>代数符号</strong>表示未知值，并基于这些符号进行符号计算，并得出导致程序出错的对应符号值条件。  </p>
<p>因此，CSA能够发现罕见的程序路径上的深层次bug。 这些路径极容易被手动测试人员或自动化测试套件忽略。一旦发现了一个bug，分析器就会绘制出导致这个bug的整条path，并在每个条件语句上标出跳转方向。  </p>
<p>不过需要注意的是，分析器只能找到那些定制去找的bug。 如果没有定制的话，即使遇到问题，分析也只会进一步进行，不会报告。 对于分析器发现的每一种特定类型的缺陷，例如空指针的解引用或缓冲区溢出，都存在一个特殊的模块(checker)，使得分析器在分析期间对此类缺陷作出响应。</p>
<p>因此，从本质上讲，分析器核心负责以符号方式执行程序，而checker订阅它们感兴趣的事件、检查基于符号值的假设是否满足、并在不满足的时候发出警告。</p>
<p>这意味着不仅可以使用分析器本身来发现缺陷，而且还可以使它适应特定的项目。 例如，可以定制自己的强制规则，或者发现特定库API的误用。为了做到这一点，需要分析器编写一个新的检查器模块。这不太困难，因为CSA是一个非常容易的工具，而这个指南应该能够帮到你。</p>
<h4 id="1-1-从写一个简单的checker上手"><a href="#1-1-从写一个简单的checker上手" class="headerlink" title="1.1 从写一个简单的checker上手"></a>1.1 从写一个简单的checker上手</h4><p>作为开始，我们先写一个极简的checker，检查C++标准中的这一条：</p>
<blockquote>
<p>basic.start.main.c : main()函数在程序中不应当被使用</p>
</blockquote>
<p>换言之，<code>main()</code>函数不应当是递归的，程序永远不应该调用<code>main()</code>，否则将是一个UB(Undefined Behavior)。寻找这个错误的过程听起来比较简单，就是在程序中寻找是否存在名字为”main”的函数调用。要出现这种错误，变成这需要不小心把一个指向main函数的指针放进了变量，把指针传了传，并最终不小心调用了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example_Test.c</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*<span class="type">main_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> **)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">main_t</span> foo = main;</span><br><span class="line">    <span class="type">int</span> exit_code = <span class="built_in">foo</span>(argc, argv); <span class="comment">// actually calls main()</span></span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使在这个简单的例子中，分析器的path-sensitive引擎相比较简单的语法检查也有不小的优势。让我们来看看CSA是如何检查的。</p>
<p>实际上，即使把main函数赋值给一个指针也算是对main函数的一种“使用”。但这里出于教学意义，我们会找出它是否真的被使用了：</p>
<p>第一步，我们来把这个checker的定义加到checker列表里。在clang的文件树里打开<code>lib/StaticAnalyzer/Checkers/Checkers.td</code>，并找个地方增加一个对checker的描述，例如在<code>alpha.core</code>分类里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MainCallChecker</span> : Checker &lt;<span class="string">&quot; MainCall&quot;</span>&gt;,</span><br><span class="line">    HelpText &lt;<span class="string">&quot;Check for calls to main&quot;</span>&gt;,</span><br><span class="line">    DescFile &lt;<span class="string">&quot; MainCallChecker.cpp&quot;</span>&gt;;    </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在重新编译clang以后，我们写的checker就应该出现在了clang的checker列表里。使用<code>clang -cc1 -analyzer-checker-help</code> 可以查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ $ clang -cc1 -analyzer -checker -<span class="built_in">help</span> </span><br><span class="line">OVERVIEW: Clang Static Analyzer Checkers List </span><br><span class="line">USAGE: -analyzer -checker &lt;CHECKER or PACKAGE ,...&gt;</span><br><span class="line">CHECKERS: </span><br><span class="line">...</span><br><span class="line">alpha.core.MainCall     Check <span class="keyword">for</span> calls to main</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个例子中，”alpha.core.MainCallChecker” 就是我们注册的checker的名字。一旦checker被注册了，它就可以通过CSA的命令行选项来启用，描述也会显示在help里。”alpha.core”是checker的分类名，例如，<code>-analyzer-checker alpha.core</code>会启用这个分类中的所有checker。</p>
<p>第二步，我们把checker的代码加入构建过程中：在<code>lib/StaticAnalyzer/Checkers/CMakeLists.txt</code>里，添加checker文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">MainCallChecker.cpp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，在checker文件里添加功能代码，我们之后会详细解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ClangSACheckers.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/BugReporter/BugType.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/Checker.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallChecker</span> : <span class="keyword">public</span> Checker &lt;check::PreCall &gt; &#123; </span><br><span class="line">        <span class="keyword">mutable</span> std::unique_ptr &lt;BugType &gt; BT;    </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call , CheckerContext &amp;C)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MainCallChecker :: <span class="built_in">checkPreCall</span>(<span class="type">const</span> CallEvent &amp;Call,CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = Call.<span class="built_in">getCalleeIdentifier</span> ())</span><br><span class="line">        <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT)</span><br><span class="line">            BT.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BugType</span>(<span class="keyword">this</span> , <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>)); </span><br><span class="line">            ExplodedNode *N = C.<span class="built_in">generateErrorNode</span>();</span><br><span class="line">        	<span class="keyword">auto</span> Report = llvm:: make_unique &lt;BugReport &gt;(*BT, BT -&gt;<span class="built_in">getName</span>(), N);</span><br><span class="line">            C.<span class="built_in">emitReport</span>(std::<span class="built_in">move</span>(Report ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ento:: <span class="built_in">registerMainCallChecker</span>(CheckerManager &amp;Mgr) &#123; </span><br><span class="line">    Mgr.registerChecker &lt;MainCallChecker &gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译clang之后，你就可以运行CSA、启用这个checker，并且看到结果了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ $ clang -cc1 -analyze -analyzer -checker=alpha.core Example_Test.c Example_Test.c:4:19: warning: Call to main</span><br><span class="line">int exit_code = foo(argc , argv); // actually calls main ()! </span><br><span class="line">				^~~~~~~~~~~~~~~</span><br><span class="line">1 warning generated</span><br></pre></td></tr></table></figure>

<h4 id="1-2-样例checker代码注解"><a href="#1-2-样例checker代码注解" class="headerlink" title="1.2 样例checker代码注解"></a>1.2 样例checker代码注解</h4><p>现在我们来看看<code>MainCallChecker</code>内部是如何工作的。<code>MainCallChecker</code>是一个path-snesitive的checker，它可以检测在不同的程序路径下，“流经”不同变量的值，并分析出所执行的路径是哪条，这点我们在前面的样例中已经提及。</p>
<h5 id="1-2-1-声明一个checker类"><a href="#1-2-1-声明一个checker类" class="headerlink" title="1.2.1 声明一个checker类"></a>1.2.1 声明一个checker类</h5><p>CSA中，checker的实现是通过继承类模板<code>Checker&lt;...&gt;</code>的，模板的参数表明了哪些回调函数是checker所订阅的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainCallChecker</span> : <span class="keyword">public</span> Checker &lt;check::PreCall &gt; &#123; </span><br><span class="line">        <span class="keyword">mutable</span> std::unique_ptr &lt;BugType &gt; BT;    </span><br><span class="line">    <span class="keyword">public</span>:   </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">checkPreCall</span><span class="params">(<span class="type">const</span> CallEvent &amp;Call , CheckerContext &amp;C)</span> <span class="type">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Checker类定义通常被放进匿名的命名空间来避免不同的checker同时被装载进CSA的时候发生名称冲突。</p>
<p><code>MainCallChecker</code>订阅了<code>checker::PreCall</code>这个事件。在每一次CSA的引擎遇到一个函数调用时，在进一步分析它之前就会调用在Checker中定义的<code>CheckPreCall()</code>回调函数。</p>
<h5 id="1-2-2-实现checker的回调函数"><a href="#1-2-2-实现checker的回调函数" class="headerlink" title="1.2.2 实现checker的回调函数"></a>1.2.2 实现checker的回调函数</h5><p>现在我们来看看<code>checkPreCall(...)</code>这个回调函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MainCallChecker :: <span class="built_in">checkPreCall</span>(<span class="type">const</span> CallEvent &amp;Call,CheckerContext &amp;C) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> IdentifierInfo *II = Call.<span class="built_in">getCalleeIdentifier</span> ())</span><br><span class="line">        <span class="keyword">if</span> (II-&gt;<span class="built_in">isStr</span>(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!BT)</span><br><span class="line">            BT.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BugType</span>(<span class="keyword">this</span> , <span class="string">&quot;Call to main&quot;</span>, <span class="string">&quot;Example checker&quot;</span>)); </span><br><span class="line">            ExplodedNode *N = C.<span class="built_in">generateErrorNode</span>();</span><br><span class="line">        	<span class="keyword">auto</span> Report = llvm:: make_unique &lt;BugReport &gt;(*BT, BT -&gt;<span class="built_in">getName</span>(), N);</span><br><span class="line">            C.<span class="built_in">emitReport</span>(std::<span class="built_in">move</span>(Report ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数中的<code>CallEvent</code>这个结构里包含了遇到函数调用这个事件时所有CSA内核所收集的信息，例如关于被调用函数、实参值的信息。</p>
<p>由于我们的checker是path-sensitive的，我们能得到的信息比直接看语法树要多很多。具体来说，即使用函数指针它也能知道被调用对象，因为CSA内核在这条执行路径上预测了这个指针的值。</p>
<p>在函数体的第一行，我们从<code>CallEvent</code>中拿到被调用函数的标识符信息(<code>IdentifierInfo</code>)。为了以防万一，我们把它放在if条件中。</p>
<p>在第二行，我们判断我们遇到的标识符的名字是不是”main”。我们只想找以”main”为名字的函数，所以后续所有的检查都应该在这一点的基础之上。</p>
<p>检查的逻辑大概就是这样，剩下的工作就是为用户生成错误报告。</p>
<h5 id="1-2-3-抛出错误报告"><a href="#1-2-3-抛出错误报告" class="headerlink" title="1.2.3 抛出错误报告"></a>1.2.3 抛出错误报告</h5><p>为了生成错误报告，我们使用回调中的另一个对象，CheckerContext。它是一个多功能组件，checker可以使用它来获取分析信息，并改变分析流程。  </p>
<p>在checker中有一个变量BT，它存储一个“错误类型”，用于区分bug的来源。 一个检查器可能有多种错误类型; 为了提高性能，它们通常被存储在检查器中并重新使用。 在第24行，检查器将其错误类型结构BT初始化为一个名为“Call to main”的错误，在类别“示例检查器”内，除非它已经初始化。  </p>
<h5 id="1-2-4-注册checker"><a href="#1-2-4-注册checker" class="headerlink" title="1.2.4 注册checker"></a>1.2.4 注册checker</h5><p>最后，需要添加一点精妙的代码来让分析器启动的时候生成checker实例。你可以使用这部分代码来在整个TU(Translation Unit)中禁用特定的checker。以下的代码创建一个（且仅一个）<code>MainCallChecker</code>的实例来传递给将要展开的事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ento:: <span class="built_in">registerMainCallChecker</span>(CheckerManager &amp;Mgr) &#123; </span><br><span class="line">    Mgr.registerChecker &lt;MainCallChecker&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-把checker编译成一个独立的模块"><a href="#1-3-把checker编译成一个独立的模块" class="headerlink" title="1.3 把checker编译成一个独立的模块"></a>1.3 把checker编译成一个独立的模块</h4><p>前面我们已经完成了在clang内部编译checker的尝试。还有另一种方法是把checker编译成一个独立插件。这种情况下，你不需要修改<code>Checkers.td</code>和<code>CmakeLists.txt</code>来运行checker。你只需要把自己的checker编译成一个独立的库，在运行时装载它。</p>
<p>如果这样做，你的目标是把你的checker编译成一个clang的plugin。你不需要挂<code>ClangSACheckers.h</code>头，而是需要挂<code>CheckerRegistry.h</code>头:</p>
<p><code>#include &quot;clang/StaticAnalyzer/Core/CheckerRegistry.h&quot;</code></p>
<p>然后在库中定义一个外部可见的函数来动态地完成checker注册的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clang_registerCheckers</span> <span class="params">(CheckerRegistry &amp;registry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">registry.<span class="built_in">addChecker</span>&lt;MainCallChecker&gt;(<span class="string">&quot;alpha.core.MainCallChecker&quot;</span>,<span class="string">&quot;Checks for calls to main&quot;</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clang的API的版本与plugin的API的版本要保持一致（换句话说，你不能把旧版本API的插件装载进新版本clang里）。所以说，checker需要保存它的版本信息在一个外部可见的变量<code>clang_analyzerAPIVersionString</code>中，来完成兼容性检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">const</span> <span class="type">char</span> clang_analyzerAPIVersionString[]= CLANG_ANALYZER_API_VERSION_STRING;</span><br></pre></td></tr></table></figure>

<p>当你使用<code>clang -cc1 -load YourChecker.so</code>之后，对应的Checker就会装载进列表中，并可以被激活。</p>
<h4 id="1-4-延伸阅读"><a href="#1-4-延伸阅读" class="headerlink" title="1.4 延伸阅读"></a>1.4 延伸阅读</h4><p><a target="_blank" rel="noopener" href="http://llvm.org/doxygen">http://llvm.org/doxygen</a></p>
<p><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen">http://clang.llvm.org/doxygen</a></p>
<p><a target="_blank" rel="noopener" href="http://clang-analyzer.llvm.org/checker_dev_manual.html">http://clang-analyzer.llvm.org/checker_dev_manual.html</a></p>
<p><a target="_blank" rel="noopener" href="http://llvm.org/devmtg/2012-11/videos/Zaks-Rose-Checker24Hours.mp4">http://llvm.org/devmtg/2012-11/videos/Zaks-Rose-Checker24Hours.mp4</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/24/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/24/%E3%80%8Aclang%20%E6%BA%90%E7%A0%81%E5%AF%BC%E8%AF%BB%E3%80%8B%20%E7%AC%94%E8%AE%B03/" class="post-title-link" itemprop="url">《clang 源码导读》 笔记(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-24 17:00:00" itemprop="dateCreated datePublished" datetime="2022-03-24T17:00:00+08:00">2022-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 18:04:21" itemprop="dateModified" datetime="2022-04-25T18:04:21+08:00">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter-3-Clang-Driver-参数解析"><a href="#Chapter-3-Clang-Driver-参数解析" class="headerlink" title="Chapter 3 Clang Driver 参数解析"></a>Chapter 3 Clang Driver 参数解析</h2><p>关注点：</p>
<ul>
<li>各个类负责的职责</li>
<li>类之间的流程</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p><code>Info</code>：保存了<code>Option</code>信息的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Entry for a single option instance in the option data table.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="comment">/// A null terminated array of prefix strings to apply to name while</span></span><br><span class="line">    <span class="comment">/// matching.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> *Prefixes;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *HelpText;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *MetaVar;</span><br><span class="line">    <span class="type">unsigned</span> ID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Kind;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> Param;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> GroupID;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> AliasID;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *AliasArgs;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Option</code>： 表示驱动程序接受的选项的一种形式。每一个具体的Arg实例对应一个特定的Option实例<br>见<a target="_blank" rel="noopener" href="https://www.llvm.org/doxygen/Option_8h_source.html#l00051">https://www.llvm.org/doxygen/Option_8h_source.html#l00051</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Option - Abstract representation for a single form of driver</span></span><br><span class="line"><span class="comment">/// argument.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An Option class represents a form of option that the driver</span></span><br><span class="line"><span class="comment">/// takes, for example how many arguments the option has and how</span></span><br><span class="line"><span class="comment">/// they can be provided. Individual option instances store</span></span><br><span class="line"><span class="comment">/// additional information about what group the option is a member</span></span><br><span class="line"><span class="comment">/// of (if any), if the option is an alias, and a number of</span></span><br><span class="line"><span class="comment">/// flags. At runtime the driver parses the command line into</span></span><br><span class="line"><span class="comment">/// concrete Arg instances, each of which corresponds to a</span></span><br><span class="line"><span class="comment">/// particular Option instance.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Arg</code>：保存具体的option信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A concrete instance of a particular driver option.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The Arg class encodes just enough information to be able to</span></span><br><span class="line"><span class="comment">/// derive the argument values efficiently.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OptTable</code>：提供了“一层”隔离，在保存足够信息的同时，尽可能lazily-created <code>Option</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Provide access to the Option info table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The OptTable class provides a layer of indirection which allows Option</span></span><br><span class="line"><span class="comment">/// instance to be created lazily. In the common case, only a few options will</span></span><br><span class="line"><span class="comment">/// be needed at runtime; the OptTable class maintains enough information to</span></span><br><span class="line"><span class="comment">/// parse command lines without instantiating Options, while letting other</span></span><br><span class="line"><span class="comment">/// parts of the driver still use Option instances where convenient.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>InputArgList</code>：保留输入的原始参数和解析后的参数列表，是ArgList的子类</p>
</li>
<li><p><code>DriverOptTable</code> 记录driver相关的info信息，是OptTable的子类</p>
</li>
</ul>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="DriverOptTable"><a href="#DriverOptTable" class="headerlink" title="DriverOptTable"></a>DriverOptTable</h5><p>是OptTable的子类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Asp"
      src="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
  <p class="site-author-name" itemprop="name">Asp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asp</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
