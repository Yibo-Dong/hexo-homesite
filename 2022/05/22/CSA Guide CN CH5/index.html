<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CH5 符号值的层次结构符号值是CSA用于描述在程序符号执行期间遇到的已知和未知值的符号。CSA使用非常复杂的符号值层次结构。表示各种符号值的基本类是SVal类。它有不同的子类，代表不同种类的符号值。还有两个辅助类MemRegion和SymExpr，分别专门处理内存区域和符号表达式。 SymExpr类的对象常常被称为符号值(symbol)，代表未知的数值；如果在分析过程中已知一个值，则称之为具体值">
<meta property="og:type" content="article">
<meta property="og:title" content="Clang Static Analyzer · Checker Developer&#39;s Guide [CN] (5)">
<meta property="og:url" content="http://example.com/2022/05/22/CSA%20Guide%20CN%20CH5/index.html">
<meta property="og:site_name" content="Good Good Study">
<meta property="og:description" content="CH5 符号值的层次结构符号值是CSA用于描述在程序符号执行期间遇到的已知和未知值的符号。CSA使用非常复杂的符号值层次结构。表示各种符号值的基本类是SVal类。它有不同的子类，代表不同种类的符号值。还有两个辅助类MemRegion和SymExpr，分别专门处理内存区域和符号表达式。 SymExpr类的对象常常被称为符号值(symbol)，代表未知的数值；如果在分析过程中已知一个值，则称之为具体值">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/ticp/Documents/notes/image-20220518152913878.png">
<meta property="og:image" content="c:/Users/ticp/Documents/notes/image-20220520155707281.png">
<meta property="article:published_time" content="2022-05-22T14:00:00.000Z">
<meta property="article:modified_time" content="2022-05-22T14:00:31.468Z">
<meta property="article:author" content="Asp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/ticp/Documents/notes/image-20220518152913878.png">

<link rel="canonical" href="http://example.com/2022/05/22/CSA%20Guide%20CN%20CH5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Clang Static Analyzer · Checker Developer's Guide [CN] (5) | Good Good Study</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Good Good Study</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Day Day up</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/22/CSA%20Guide%20CN%20CH5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
      <meta itemprop="name" content="Asp">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Good Good Study">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Clang Static Analyzer · Checker Developer's Guide [CN] (5)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-22 22:00:00 / Modified: 22:00:31" itemprop="dateCreated datePublished" datetime="2022-05-22T22:00:00+08:00">2022-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSA/" itemprop="url" rel="index"><span itemprop="name">CSA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="CH5-符号值的层次结构"><a href="#CH5-符号值的层次结构" class="headerlink" title="CH5 符号值的层次结构"></a>CH5 符号值的层次结构</h2><p>符号值是CSA用于描述在程序符号执行期间遇到的已知和未知值的符号。CSA使用非常复杂的符号值层次结构。表示各种符号值的基本类是SVal类。它有不同的子类，代表不同种类的符号值。还有两个辅助类MemRegion和SymExpr，分别专门处理内存区域和符号表达式。</p>
<p>SymExpr类的对象常常被称为符号值(symbol)，代表未知的数值；如果在分析过程中已知一个值，则称之为具体值（concrete value）。MemRegion对象，也即“regions”，有两种用途：作为分析器内存模型中区域存储绑定的位置，以及用于表示指针值。</p>
<p>这三个类之间有很大的联系。例如，区域可以“基于”符号和具体值（例如，指针符号指向的区域，或具有已知或未知索引的数组元素的区域），符号可以“基于”区域（例如，定义为区域初始值的符号）。</p>
<p>此外，SVal分为两大类：表示左值的<code>loc</code>和右值的<code>NonLoc</code>。</p>
<table>
<thead>
<tr>
<th></th>
<th>角色</th>
<th>SVal</th>
<th>MemRegion</th>
<th>SymExpr</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用作范围约束的key</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>2</td>
<td>用作区域绑定的key</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>用作区域绑定的value</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>用作环境value</td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>携带污染</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>6</td>
<td>携带元数据</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>用作元数据值</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>8</td>
<td>存储在GDM中</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
<p>这只对约束符号才有意义；具体的值是已知的，所以进一步给它们分配整数范围约束是没有意义的，而且内存区域地址并不会在编译时真正定义。当然，区域存储通过为区域指定任意值来工作，而环境通过为AST表达式指定任意值来工作。</p>
<p>表格里的第五行可能出乎你的意料，如上所述，我们一直在讨论受污染的存储区域，一些处理受污染内存区域的方法会接受任意的<code>SVal</code>。然而，当受污染分析处理符号以外的值时，它只会试图在其中找到符号值，这点我们将在第5.6小节中详细讨论。元数据符号的概念将在后面的5.5.5中讨论。最后，GDM几乎可以承载任何东西，这就是“G”的含义。</p>
<h4 id="5-1-构建符号值"><a href="#5-1-构建符号值" class="headerlink" title="5.1 构建符号值"></a>5.1 构建符号值</h4><p><code>SValBuilder</code>类提供了构造<code>SVal</code>对象的方法。它允许构造各种<code>SVal</code>和各种<code>SymExpr</code>（必要时将后者表示为<code>SVal</code>）。它还允许对符号值进行求值。</p>
<p>但是，要构建内存区域，应该使用<code>MemRegionManager</code>对象。有时，能够构造子区域是很有用的（例如，具有已知声明的结构区域的字段区域，以便稍后获得字段值）。</p>
<p>你几乎永远不应该构建一个<code>SymExpr</code>。要构造符号的少数情况包括创建某种<code>eval::Call</code>中创建某种<code>SymbolConjured</code>符号，以及在checker使用此机制时构造符号元数据(SymbolMetadata)。然而，大多数时候，您会从环境或区域存储收到所有必要的符号，甚至很少关心它们的种类。</p>
<p>在任何情况下，您都应该使用<code>SValBuilder</code>的方法，而不是直接访问<code>SymbolManager</code>对象，来构造所有类型的<code>SymExpr</code>。如果请求的符号是整型的，这些方法将返回包含该符号的<code>nonloc::SymbolVal</code>；如果请求的是指针类型，则返回包含包装该符号的<code>SymbolRegionVal</code>。在这两种情况下，都可以调用生成的<code>SVal</code>的<code>getAsSymbol()</code>方法来获取<code>SymExpr</code>本身。</p>
<h4 id="5-2-分析器的内存模型"><a href="#5-2-分析器的内存模型" class="headerlink" title="5.2  分析器的内存模型"></a>5.2  分析器的内存模型</h4><p><code>MemRegion</code>是一个内存段，当它存储在指针类型的SVal中时，它表示内存段的第一个字节的地址；但是，你仍然应该将MemRegion对象想象为承载了关于整个内存段的信息。</p>
<p>SVal类的getAsRegion()方法适用于以下SVal类型：</p>
<ul>
<li><code>loc::MemRegionVal</code> : 一个指针值，被描述为给定区域的第一个字节的地址</li>
<li><code>nonloc::LocAsInteger</code>: 一个类似的指针值，只存储在整数中。这种SVal表示指向整数强制转换的指针的结果。</li>
</ul>
<p>一些内存区域是其他区域的子区域。子区域是段内的子段。子区域继承自SubRegion类。每个子区域都有一个长度（“范围”），可以通过SubRegion的getExtent()获得该长度分区域方法。范围可以是具体的，也可以是符号化的。 </p>
<p>其它的内存区域，我们称之为”memory spaces”，并不属于其它的区域。</p>
<p>每个子区域恰有一个通过getSuperRegion()方法获得的直接超区域。以存储空间作为其直接超级区域的存储区域称为基区域(base region)。如果一个区域既不是内存空间也不是基区，那么在其超级区域链的末端正好有一个基区。有一个单独的类家族用于表示基本区域：通过只查看区域的类，可以确定它是内存空间内的基本区域，还是位于另一个基本区域内。 </p>
<p>可以使用getMemorySpace()方法获取该区域所属的内存空间，并使用getBaseRegion()获取任何子区域的基本区域。</p>
<p>基本区域（内存空间的直接子区域）可以是类型化的，也可以是非类型化的。类型化区域是保存已知类型值的区域。非类型化区域是具有未知类型值的区域，尽管您可能大致知道存储在那里的内容或其来源。</p>
<p>例如，考虑以下代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> x , y ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line"><span class="type">int</span> u , v ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="type">int</span> t ;</span><br><span class="line">B * b ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">( C c )</span> </span>&#123;</span><br><span class="line">c.b[<span class="number">5</span>].y ; <span class="comment">// &lt;-- that</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，下图大致描述了第20行上描述字段y的区域系统。 </p>
<p><img src="C:\Users\ticp\Documents\notes\image-20220518152913878.png" alt="image-20220518152913878"></p>
<p>如果你把这个区域dump()出来，你可能会看到：</p>
<p><code>base &#123; element &#123; SymRegion &#123; reg_$0 &lt;c - &gt;b &gt;&#125; ,5 S32b , struct B &#125; , A &#125; - &gt; y</code></p>
<p>用文字表述，它的意思是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FieldRegion for declaration of member variable y,</span><br><span class="line">	inside CXXBaseRegion for declaration of class A,</span><br><span class="line">		inside ElementRegion for element number 5 of type B,</span><br><span class="line">			inside SymbolicRegion for the pointer symbol of SymbolRegionValue kind,which represents the initial value of:</span><br><span class="line">FieldRegion for declaration of member variable b,</span><br><span class="line">	VarRegion for declaration of a local variable c.</span><br></pre></td></tr></table></figure>

<p>在读完本节后，你应该可以理解这张图的大部分内容（除了SymbolRegionValue，我们在5.5节会提到） </p>
<h5 id="5-2-1-内存空间"><a href="#5-2-1-内存空间" class="headerlink" title="5.2.1 内存空间"></a>5.2.1 内存空间</h5><p>内存空间继承自MemSpaceRegion类。大多数内存空间都是“单元集”，实际上它们很少： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-GlobalSpaceRegion-四个不同内存空间的基类：</span><br><span class="line">	-NonStaticGlobalSpaceRegion-所有非静态全局变量的单个内存空间，分为三个：</span><br><span class="line">		-GlobalImmutableSpaceRegion，由无法修改的全局变量组成</span><br><span class="line">		-GlobalSystemSpaceRegion，其中包括最有可能只由系统调用修改的变量，如errno</span><br><span class="line">		-GlobalInternalSpaceRegion，由其他全局变量组成</span><br><span class="line">	-StaticGlobalSpaceRegion-所有静态全局变量的内存空间</span><br><span class="line">-HeapPasceRegion-保存在堆上分配的所有区域</span><br><span class="line">-StackSpaceRegion-两个不同内存空间的基类：</span><br><span class="line">	-StackArgumentsSpaceRegion-函数调用参数的内存空间</span><br><span class="line">	-StackLocalSpaceRegion-局部变量的内存空间。</span><br><span class="line">	（请注意，与其他内存空间不同，可能有多个StackSpaceRegion实例-每个StackFrameContext对应一个实例。）</span><br><span class="line">-UnknownSpaceRegion—当分析器不知道区域实际存储在哪里时。 </span><br></pre></td></tr></table></figure>

<p>内存空间很重要，因为如果区域位于不同的内存空间中，即使这些区域的所有其他特征都相同，它们也会被认为是不同的。例如，函数参数变量在不同调用中的区域是不同的，因为即使变量声明是相同的，它们的内存空间也是由不同的堆栈帧上下文定义的。</p>
<h5 id="5-2-2-无类型基本区域"><a href="#5-2-2-无类型基本区域" class="headerlink" title="5.2.2 无类型基本区域"></a>5.2.2 无类型基本区域</h5><p>有三种类型的无类型区域：</p>
<ul>
<li><p>AllocaRegion<br>通过调用标准C库的alloca()函数在堆栈上分配的区域。此区域是非类型化的，因为此函数分配原始数据。<br>AllocareRegion始终位于StackLocalsSpaceRegion中。</p>
</li>
<li><p>SymbolicRegion<br>指针指向的区域，其值是一个符号表达式。这个区域是非类型化的，因为指针可以在C中自由转换，并且不能确保它指向的数据类型与指针类型匹配。SymbolicRegion类值得特别注意，因为指针符号（即使其类型是指针类型）在技术上是非LOC的。因此，SymbolicRegion类的目的是表达和传递Loc部分——一个在创建指针值之后创建的区域，而不是反过来。</p>
<p>如果一个子区域以SymbolicRegion作为其基本区域，则该区域被称为具有符号基础，并且该符号区域被称为该区域的符号基础。MemRegion的getSymbolicBase()方法返回指向符号基区的指针，如果基区不是符号的，则返回空指针。这个方法当您需要确定一个复杂的子区域是否实际与某个特定的指针符号相关时，将非常有用。</p>
<p>SymbolicRegion通常位于UnknownSpaceRegion中，因为指针的性质通常是未知的。然而，有时已知指针指向heap（例如，如果它是由默认操作符new返回的），那么该区域将位于HeapSpaceRegion中。堆符号区域是使用MemRegionManager的getSymbolCheapRegion()方法创建的。</p>
</li>
</ul>
<h5 id="5-2-3-有类型基本区域与有类型值"><a href="#5-2-3-有类型基本区域与有类型值" class="headerlink" title="5.2.3 有类型基本区域与有类型值"></a>5.2.3 有类型基本区域与有类型值</h5><p>类型化区域是共同具有称为TypedValueRegion的祖先类的区域，尽管并非其所有继承者都是基区域；实际上，基本区域的子区域也是类型化的。类型化区域的种类更多：</p>
<ul>
<li><p>VarRegion</p>
<p>VarRegion是变量的区域。对于每个AST全局或静态变量声明，都会定义一个VarRegion。对于堆栈变量，区域可以在不同的函数调用中有所不同，只需作为不同StackSpaceRegion内存空间的子区域即可。还要注意的是，类的成员变量根本不是基区，也从来没有用VarRegion表示。</p>
<p>根据变量声明的性质，VarRegion可能位于各种内存空间中。 </p>
</li>
<li><p>CXXThisRegion</p>
<p>CXXThisRegion是在C++方法调用期间存储隐式this指针的区域。这个类型化区域始终位于堆栈上，每个堆栈帧上下文（即每个StackArgumentsSpaceRegion空间）最多有一个CXXThisRegion，就像VarRegion的函数参数一样。</p>
<p>请注意，CXXThisRegion不是对象本身，而是一个存放指针的堆栈区域。对象本身就是存储在该区域中的符号值。对于顶级调用，对象区域将被描述为顶级堆栈帧的CXXThisRegion的SymbolRegionValue的SymbolRegion区域；特别是，它将是非类型化的，即使CXXThisRegion本身始终是类型化的。对于过程间分析期间的嵌套函数调用，可以键入当前对象区域（例如，当嵌套调用的堆栈帧的CXXThisRegion包含指向已知变量的VarRegion的指针时）。 </p>
</li>
<li><p>CXXTempObjectRegion<br>CXXTempObjectRegion表示C++临时对象的内存区域。当C++的语义需要创建辅助的不可见对象时，例如，在不使用new操作符直接调用构造函数来创建对象时，就会出现这种情况。此区域保存导致它出现的AST表达式的内存。</p>
<p>CXXTempObjectRegion可能位于StackLocalsSpaceRegion中，有时也可能位于GlobalInternalSpaceRegionKind中（当使用MemRegionManager的getCXXStaticTempObjectRegion()方法创建它时）。</p>
</li>
<li><p>CompoundLiteralRegion</p>
<p>CompoundLiteralRegion表示初始值设定项列表（“复合文字”）对象的内存区域。 </p>
</li>
<li><p>StringRegion</p>
<p>字符串文字的区域</p>
</li>
</ul>
<h5 id="5-2-4-无类型值的类型化基区域"><a href="#5-2-4-无类型值的类型化基区域" class="headerlink" title="5.2.4 无类型值的类型化基区域"></a>5.2.4 无类型值的类型化基区域</h5><p>有一些特殊类型的区域，继承自TypedRegion，但不是TypedValueRegion。这些区域具有定义良好的“位置”（指针）类型，但是它们存储的值的类型没有定义为位置类型的指针对象类型：</p>
<ul>
<li>BlockDataRegion<br>表示块内存储数据的基本区域（Apple Inc.对C和C++的非标准扩展）。这些区域负责处理块的代码和数据，并实现使用闭包的方法。</li>
<li>CodeTextRegion<br>表示程序代码的内存区域，而不是数据。有两个子类：<ul>
<li>FunctionTextRegion，函数代码，一般用于表示分析器中的函数指针值</li>
<li>BlockTextRegion，用于表示块代码。</li>
</ul>
</li>
</ul>
<h5 id="5-2-5-基区域的子区域"><a href="#5-2-5-基区域的子区域" class="headerlink" title="5.2.5 基区域的子区域"></a>5.2.5 基区域的子区域</h5><p>基本区域的子区域始终是类型化的，即使基本区域是非类型化的。</p>
<ul>
<li>CXXBaseObjectRegion是基类对象在派生类对象区域内的区域。该区域由AST中的基类声明定义</li>
<li>ElementRegion是实心一维数组中数组元素的区域。元素的索引是数组索引类型的任意非loc符号值，它可以是具体的整数，也可以是符号。该区域还携带类型信息；具有相同索引但不同类型的相同超区域的元素区域被视为不同的。<br>ElementRegion还用于表示非类型化区域的类型转换。例如，转换为类型<code>T*</code>的符号指针的值表示为该指针上符号区域的值类型T的元素区域。如果指针被进一步转换为另一种类型<code>S*</code>，则此ElementRegion可以替换为值类型S的另一个ElementRegion。</li>
<li>FieldRegion是结构、类或联合内的字段区域。与VarRegion类似，该区域也基于AST变量声明。</li>
</ul>
<p>请注意，ElementRegion并不表示指针解引用（相反，SymbolicRegion表示指针解引用），并且下标指针和数组的处理方式完全不同。例如，考虑一个函数foo：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>*p, <span class="type">int</span> a[<span class="number">5</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ticp\Documents\notes\image-20220520155707281.png" alt="image-20220520155707281"></p>
<p>那么a[5]将是参数变量a的VarRegion的ElementRegion，它位于StackArgumentsSpaceRegion中的某个位置：<br><code>element&#123;a,5 S32b,int&#125;</code></p>
<p>然而，p[5]是未知父区域中SymbolicRegion的ElementRegion，为参数变量p的符号指针值而构造：<br><code>element&#123;SymRegion&#123;reg_$0&lt;p&gt;&#125;,5 S32b, int&#125;</code></p>
<h4 id="5-3-具体值"><a href="#5-3-具体值" class="headerlink" title="5.3 具体值"></a>5.3 具体值</h4><p>具体值是编译时已知的值。如果一个整数变量的值已知为42，则存在一个表示它的具体值，并且没有两个不同的符号值可能由于某些意外同时表示它；一个就够了。 </p>
<h5 id="5-3-1-数字值"><a href="#5-3-1-数字值" class="headerlink" title="5.3.1 数字值"></a>5.3.1 数字值</h5><p>最原始的具体值就是表示编译时已知值的整数。在内部，nonloc::ConcreteInt在内部持有一个llvm::APSInt；您可以通过getValue()来获取它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nonloc::ConcreteInt CI = Val.<span class="built_in">castAs</span>&lt;nonloc::ConcreteInt&gt;();</span><br><span class="line"><span class="type">uint64_t</span> Int = CI.<span class="built_in">getValue</span>().<span class="built_in">getLimitedValue</span>();</span><br></pre></td></tr></table></figure>

<p>nonloc::ConcreteInt类的不同实例具有不同的数值、类型大小和符号性。然而，对于三者的每个组合，只有一个nonloc::ConcreteInt表示它；您无法区分从不同来源获得的两个32位有符号零。</p>
<p>loc::ConcreteInt是表示已知指针值的具体整数。它的内部类似于nonloc::ConcreteInt。通常loc::ConcreteInt的实例是指针宽度的无符号整数。在编译时不太可能知道内存地址，因此在loc::ConcreteInt中最常见的值是0，表示空指针。 </p>
<h5 id="5-3-2-复合值"><a href="#5-3-2-复合值" class="headerlink" title="5.3.2 复合值"></a>5.3.2 复合值</h5><p>具体复合值的最简单示例是nonloc::CompoundVal，它表示初始值设定项列表或字符串的具体r值。在内部，它包含存储在文本中的SVal的llvm::ImmutableList。</p>
<p>然而，分析器中使用了另一个复合值，在分析中出现频率高很多，它就是nonloc::LazyCompoundVal。该值是一个r-value，表示分析过程中给定时刻任何结构“作为一个整体”的快照。该值远不可被称为“具体值”，因为其中的许多字段都是未知的或符号化的。nonloc::LazyCompoundVal存储两项内容：</p>
<ul>
<li>对正在快照的TypedValueRegion的引用（是的，它总是有类型的）</li>
<li>从创建它的ProgramState获取的整个Store对象的副本。</li>
</ul>
<p>从本质上讲，nonloc::LazyCompoundVal是为了分析器的性能优化。因为Store是不可变的，所以创建nonloc::LazyCompoundVal是一个低成本的操作。请注意，Store包含程序状态下的所有区域绑定，而不仅仅与区域相关。之后，如有必要，可以对该值进行解压缩；例如，将其分配给另一个变量时。 </p>
<h4 id="5-4-特殊值"><a href="#5-4-特殊值" class="headerlink" title="5.4 特殊值"></a>5.4 特殊值</h4><p>本小节描述了为特殊目的保留的两个单例值。</p>
<h5 id="5-4-1-未定义值"><a href="#5-4-1-未定义值" class="headerlink" title="5.4.1 未定义值"></a>5.4.1 未定义值</h5><p>每当分析器内核需要强调某个东西（表达式或区域）的值根据语言标准<strong>未定义</strong>时，就会生成一个UndefinedVal。UndefinedVal就一种：您无法区分从不同来源获得的两个UndefinedVal。</p>
<p>大多数情况下，每当出现未定义的行为时，都应该有一个checker来警告发生了未定义的行为。有多个官方检查模块在核心中抛出此类警告。</p>
<p>出现UndefinedVal的常见情况是试图获取未初始化变量的值。</p>
<p>这是在ProgramState的方法assume(…)中唯一被禁止的值。</p>
<h5 id="5-4-2-未知值"><a href="#5-4-2-未知值" class="headerlink" title="5.4.2 未知值"></a>5.4.2 未知值</h5><p>每当符号执行引擎无法用符号表示某个值时，它就会创建另一个称为UnknownVal的特殊值。与UndefinedVal一样，UnknownVal是一个单例值；你不能区分从不同来源获得的两个未知值。但是，您可以区分UnknownVal和UndefinedVal。</p>
<p><code>UnknownVal</code>可能随时随地出现。当符号表达式超过其复杂性限制时，通常会出现这种情况。它在任何地方的出现，无论多么关键，都不会立即表明程序中有错误，但很可能表明分析器内核出现故障：未知值缺少明确的符号，这会破坏符号执行的目的。大多数情况下，分析器会为这些值“变戏法”地搞一个特殊符号，但有时它希望确保您完全不对该值进行任何假设，因而创建一个未知值。当您在checker回调中遇到未知值时，最好避免抛出警告。</p>
<h4 id="5-5-符号表达式"><a href="#5-5-符号表达式" class="headerlink" title="5.5 符号表达式"></a>5.5 符号表达式</h4><p>符号表达式，也被称为符号，毫无疑问是符号执行背后整个理念的本质。</p>
<p>符号是永恒的：符号值在分析过程中不能“改变”。创建符号后，它在整个分析过程中表示相同的值。然而，当分析在程序中进一步进行时，可能会收集有关该值的新信息，并以对该符号施加范围约束的形式存储在ProgramState中。</p>
<p>例如，在if语句的true分支上，表示条件值的符号将为非零。在false分支上，它将被认为等于零，本质上变成了一个具体的值；事实上，getSVal(…)将在内部用具体的整数0替换这样的符号。 </p>
<p>然而，符号值的分类并不那么重要。大多数情况下，关于符号，您需要了解的最重要的一点是，由相同符号表示的值总是相等的，而不同的符号可能相同也可能不同。事实上，即使所有的符号都是SymbolConjured类型，大多数分析都能很好地工作。以下是我们因拥有不同符号类的层次结构而获得的一些好处：</p>
<ul>
<li>RangeConstraintManager使用符号二进制表达式类来显著简化约束条件，例如，<code>(x+3)&gt;5</code>很容易转换为x&gt;2，如果表示（x+3）的符号不记得x或3的任何信息，这将很难实现。</li>
<li>通过对符号中存储的区域的引用，污染自动从污染区域传播到表示其值的数据符号。</li>
<li>在任何时候，我们都可以轻松地以高层次的方式追踪符号的起源。如果我们想找出复现分析器发现的bug所需的条件，我们可以通过查看程序状态内的符号来执行此操作。</li>
<li>它也对调试很有用，有时（很少）checker本身的内部逻辑依赖于符号类型。然而，你应该知道你在做什么；这个技术常被误用用于「快速而肮脏且错误」的启发式。本小节应该让您大致了解什么是符号，什么不是符号。</li>
</ul>
<p>符号值总是有一种类型，即整数或指针。</p>
<p>SVal类的getAsSymbol()方法适用于以下SVal类型：</p>
<ul>
<li>nonloc::SymbolVal，作为“符号”本身的值。</li>
<li>loc::MemRegionVal，如果其中的区域是一个符号区域（“符号指针”，因为nonloc::SymbolVal总是nonloc，此方法将指针表示为loc值）。在这种情况下，该方法将返回为其构造区域的符号。如果getAsSymbol()的可选布尔参数设置为true，则此方法也适用于具有符号基的任意区域。</li>
<li>nonloc::LocAsInteger，从基础loc::MemRegionVal（如果有）中提取符号指针。</li>
</ul>
<h5 id="5-5-1-操作符号"><a href="#5-5-1-操作符号" class="headerlink" title="5.5.1 操作符号"></a>5.5.1 操作符号</h5><p>有三个符号表示其他符号上的二进制运算符：</p>
<ul>
<li>SymIntExpr表示另一个符号和具体整数之间的二进制运算结果，例如x+5；</li>
<li>IntSymExpr表示一个具体整数和另一个符号之间的二进制运算的结果，例如3&gt;x；</li>
<li>SymSymExpr表示一个具体整数和另一个符号之间的二进制运算的结果（如x∗ y）。 请注意，SymSymExpr符号很少由分析器创建，因为它们对于RangeConstraintManager几乎没有用处，因为RangeConstraintManager无法处理复杂的约束。通常，当其中一个操作数被污染时，会出现SymSymExpr，以保存污染信息。 </li>
<li>还有SymbolCast，它表示从另一个符号转换为特定类型的结果。</li>
</ul>
<h5 id="5-5-2-戏法符号"><a href="#5-5-2-戏法符号" class="headerlink" title="5.5.2 戏法符号"></a>5.5.2 戏法符号</h5><p>SymbolConjured是在其他所有操作都失败时的一种回退：分析器根本无法从表达式中理解任何含义，因此它至少生成一些符号以保持路径敏感性。SymbolConjured的常见示例包括由于其主体的源代码不可用或其他原因而未由分析器建模的函数的返回值；它也用于失效的目的。 </p>
<h5 id="5-5-3-区域值符号"><a href="#5-5-3-区域值符号" class="headerlink" title="5.5.3 区域值符号"></a>5.5.3 区域值符号</h5><p>我们已经多次提到，最原始的“敏感”原子（“数据”）符号可能是SymbolRegionValue。它表示分析开始时存储在内存区域中的值。此符号包含对区域的引用。考虑以下示例： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = a;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析开始时（第2行之前），b的值是UndefinedVal，而a的值是SymbolRegionValue类的符号，表示参数变量a的区域值。</p>
<p>在第2行之后，b的值更改为代表a值的SymbolRegionValue</p>
<p>在第3行，a的值更改为nonloc::ConcretInt，值为1。但是，b仍然为变量a的区域保留SymbolRegionValue类型的符号，它仍然表示a的原始值，而不是新的具体值1。另一个与SymbolRegionValue密切相关的原子符号是SymbolDerived。它表示另一个符号被写进了一个直接或间接的超级区域之后，一个区域的值。SymbolDerived包含对父符号和父区域的引用。这个符号主要是一种技术黑客行为。通常SymbolDerived在吴无效化之后出现：某一类型的整个结构被一个戏法符号打破，然后其字段的值通过戏法符号的SymbolDerived和字段区域的符号来表示。在任何情况下，SymbolDerived与SymbolRegionValue类似，只是指分析过程中某个事件之后的值，而不是分析开始时的值。 </p>
<h5 id="5-5-4-范围符号"><a href="#5-5-4-范围符号" class="headerlink" title="5.5.4 范围符号"></a>5.5.4 范围符号</h5><p>正如我们在第5.2小节中提到的，每个内存区域都是一段字节。我们通常对第一个字节的地址感兴趣，但有时我们可能会试图找出区域的长度（“范围”），这可能是已知的（对于普通可变区域）或未知的（通常是符号区域，实际上可能是长度未知的数组）。当范围未知时，它用一个称为SymbolExtent的特殊符号表示。此符号包含区域的引用。 </p>
<p>当然，如果需要获取某个区域的范围，则不应手动创建新的SymbolExtent；您可以依赖SubRegion的getExtent(…)方法。</p>
<h5 id="5-5-5-元数据符号"><a href="#5-5-5-元数据符号" class="headerlink" title="5.5.5 元数据符号"></a>5.5.5 元数据符号</h5><p>元数据符号是具有特定于checker含义的符号，与内存区域相关联。checker可以创建这样的符号，并管理它们的生存期和垃圾收集（通过check::LiveSymbols回调）。analyzer核心从不自行创建SymbolMetadata；只有checker才能创建此类符号。</p>
<p>可以使用SValBuilder创建新的符号元数据。下面是官方alpha的一个示例代码。它创建表示字符串长度的元数据符号： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SValBuilder &amp; SVB = C.<span class="built_in">getSValBuilder</span>();</span><br><span class="line">QualType SizeTy = SVB.<span class="built_in">getContext</span> ().<span class="built_in">getSizeType</span> ();</span><br><span class="line">SVal StrLength = SVB.<span class="built_in">getMetadataSymbolVal</span>(CStringChecker::<span class="built_in">getTag</span>(),MR,Ex,SizeTy,C.<span class="built_in">blockCount</span> ());</span><br></pre></td></tr></table></figure>

<p>SymbolMetadata由以下成分组成：</p>
<ul>
<li>符号标记，唯一标识一种元数据符号的void*。在本例中，正在使用检查器对象的静态getTag()方法返回的检查器本身的唯一标识符。</li>
<li>元数据绑定到的父区域；在我们的例子中，它是定义长度的字符串区域。</li>
<li>符号出现的AST表达式。</li>
<li>符号的预期类型。正如SValBuilder方法所期望的那样，如果此类型是Loc，则生成的SVal将是Loc::MemRegionVal类型，带有一个包装符号的符号区域。</li>
<li>-块计数：分析期间访问CFG块的次数。这允许在分析过程中多次通过同一表达式时，对同一区域的同一表达式上创建的符号进行区分。</li>
</ul>
<h5 id="5-5-6-污染值"><a href="#5-5-6-污染值" class="headerlink" title="5.5.6 污染值"></a>5.5.6 污染值</h5><p>如上所述，任何符号，且只有符号，都可能带有污染。然而，为了方便起见，其他值被称为从它们所依赖的符号继承污染信息。下面是通过符号值层次结构进行污染传播的完整案例列表：</p>
<ul>
<li>在以下情况下称内存区域受到污染：<ul>
<li>使用污染指针符号构造的符号区域；</li>
<li>当使用受污染的索引值构造ElementRegion时；</li>
<li>任何类型的区域都会从其超级区域继承污染。</li>
</ul>
</li>
<li>在以下情况下，符号可以继承污染，而不考虑其自身的污染信息：<ul>
<li>SymbolRegionValue可以从其父区域继承污染；</li>
<li>SymbolDerived可以从其父符号继承污染，但不能从其父区域继承污染；</li>
<li>所有运算符号都从其操作数继承污染。</li>
</ul>
</li>
<li>当用getAsSymbol()提取的符号或用getAsRegion()提取的区域被污染时，SVal被称为被污染。</li>
</ul>
<p>这些启发式方法大大简化了checker中的污染操作。</p>
<h4 id="5-7-理解debug转储"><a href="#5-7-理解debug转储" class="headerlink" title="5.7 理解debug转储"></a>5.7 理解debug转储</h4><p>所有的三种符号值类都允许使用一个方便的dump()方法进行调试。对于大多数值类型，此方法会生成一个可识别的模式，它可以告诉您有关值的许多有用信息。考虑一个例子： </p>
<p><code>reg_$2 &lt; element &#123; SymRegion &#123; derived_$1 &#123; conj_$0 &#123; int &#125; ,a - &gt; ptr &#125;&#125; ,0 S32b , int &#125; &gt;</code></p>
<p>此SVal是一个符号，即SymbolRegionValue，由reg_$N&lt;…&gt;包装器表示。数字N是分配给SymbolManager对象内每个符号的内部符号计数器。 </p>
<p>此符号表示ElementRegion中有符号整数的原始值，索引0位于对应于符号指针的特定SymbolicRegion内。分析器无法确定该指针是指向数组还是指向单个整数；但是，可以肯定的是，为了获得原始值，该指针会被取消引用。</p>
<p>指针本身是一个SymbolDerived，它是从int类型的SymbolConjured派生出来的，用于某个结构变量a的字段ptr的FieldRegion。SymbolDerived本身是SymbolRegion的基础，它必然是一个指针值。然而，SymbolConjured的类型不是指针；它很可能是结构a失效的结果。</p>
<p>因此，该值可以用文字描述为“失效期间最初存储在a.ptr字段中出现的指针后面的整数的值”。考虑另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; base &#123; base &#123; base &#123;d , C &#125; , B &#125; , A &#125; [ as <span class="number">64</span> bit integer ]</span><br></pre></td></tr></table></figure>

<p>此值是一个nonloc::LocAsInteger，表示转换为64位整数的位置的具体值。该位置是一个loc::MemRegionVal（因此前缀“&amp;”）保存某个区域。区域本身是对象d的类a的C++基对象的区域（它可能属于类d，您可以通过转储变量d的声明来检查这一点）。但是，由于D不是a的直接后代，因此可以在区域层次结构中看到整个类继承路径。</p>
<h4 id="5-8-延伸阅读"><a href="#5-8-延伸阅读" class="headerlink" title="5.8 延伸阅读"></a>5.8 延伸阅读</h4><p>Z.Xu，T.Kremenek和J.Zhang在一篇文章中详细描述了Clang静态分析器的存储模型：</p>
<p>Z. Xu, T . Kremenek, and J. Zhang. A memory model for static analysis of C programs. In: ISoLA’10 Proceedings of the 4th<br>international conference on Leveraging applications of formal methods, verification, and validation. pp. 535–548 (2010)</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/11/CSA%20Guide%20CN%20CH4/" rel="prev" title="Clang Static Analyzer · Checker Developer's Guide [CN] (4)">
      <i class="fa fa-chevron-left"></i> Clang Static Analyzer · Checker Developer's Guide [CN] (4)
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CH5-%E7%AC%A6%E5%8F%B7%E5%80%BC%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">CH5 符号值的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E6%9E%84%E5%BB%BA%E7%AC%A6%E5%8F%B7%E5%80%BC"><span class="nav-number">1.0.1.</span> <span class="nav-text">5.1 构建符号值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">5.2  分析器的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">5.2.1 内存空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">5.2.2 无类型基本区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8C%BA%E5%9F%9F%E4%B8%8E%E6%9C%89%E7%B1%BB%E5%9E%8B%E5%80%BC"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">5.2.3 有类型基本区域与有类型值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-4-%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%96%E5%9F%BA%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">5.2.4 无类型值的类型化基区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-%E5%9F%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%AD%90%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">5.2.5 基区域的子区域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%85%B7%E4%BD%93%E5%80%BC"><span class="nav-number">1.0.3.</span> <span class="nav-text">5.3 具体值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-%E6%95%B0%E5%AD%97%E5%80%BC"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">5.3.1 数字值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-%E5%A4%8D%E5%90%88%E5%80%BC"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">5.3.2 复合值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="nav-number">1.0.4.</span> <span class="nav-text">5.4 特殊值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-1-%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%80%BC"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">5.4.1 未定义值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-2-%E6%9C%AA%E7%9F%A5%E5%80%BC"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">5.4.2 未知值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.5 符号表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">5.5.1 操作符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-%E6%88%8F%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">5.5.2 戏法符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-%E5%8C%BA%E5%9F%9F%E5%80%BC%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">5.5.3 区域值符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-%E8%8C%83%E5%9B%B4%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">5.5.4 范围符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-5-%E5%85%83%E6%95%B0%E6%8D%AE%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.0.5.5.</span> <span class="nav-text">5.5.5 元数据符号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-6-%E6%B1%A1%E6%9F%93%E5%80%BC"><span class="nav-number">1.0.5.6.</span> <span class="nav-text">5.5.6 污染值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-7-%E7%90%86%E8%A7%A3debug%E8%BD%AC%E5%82%A8"><span class="nav-number">1.0.6.</span> <span class="nav-text">5.7 理解debug转储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-8-%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="nav-number">1.0.7.</span> <span class="nav-text">5.8 延伸阅读</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Asp"
      src="https://th.bing.com/th/id/R.755c49133457b51f426d5ecede1204e7?rik=Mma9LI1YW%2bV9QQ&pid=ImgRaw&r=0">
  <p class="site-author-name" itemprop="name">Asp</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asp</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
